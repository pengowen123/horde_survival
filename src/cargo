#![feature(prelude_import)]
#![no_std]
#![feature(plugin)]
#![plugin(clippy)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;

// Graphics
#[macro_use]
pub extern crate gfx;
extern crate gfx_core;
extern crate gfx_window_glutin;
extern crate gfx_device_gl;
extern crate glutin;
extern crate cgmath;
extern crate image;
#[macro_use]
extern crate conrod;

// Logging
#[macro_use]
extern crate log;
extern crate log_panics;

// Misc
extern crate rand;
extern crate time;
extern crate random_choice;
extern crate image_utils;
extern crate collision;
extern crate shader_version;

#[macro_use]
mod hslog {

    // Initialize logger


    // Initialize states



    // Event loop



    #[macro_use]
    pub mod log_utils {
        pub trait CanUnwrap {
            fn can_unwrap(&self)
            -> bool;
        }
        impl <T> CanUnwrap for Option<T> {
            fn can_unwrap(&self) -> bool { self.is_some() }
        }
        impl <T, E> CanUnwrap for Result<T, E> {
            fn can_unwrap(&self) -> bool { self.is_ok() }
        }
    }
    pub use self::log_utils::*;
    use log::*;
    use time;
    use platform::misc::NEWLINE;
    use consts::log_str::*;
    use std::fs::File;
    use std::io::Write;
    use std::sync::Mutex;
    pub fn init() {
        let file =
            match File::create(LOG_FILE) {
                Ok(f) => f,
                Err(e) => {
                    $crate::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1({
                                                                                   static __STATIC_FMTSTR:
                                                                                          &'static [&'static str]
                                                                                          =
                                                                                       &["Failed to created log file: "];
                                                                                   __STATIC_FMTSTR
                                                                               },
                                                                               &match (&e,)
                                                                                    {
                                                                                    (__arg0,)
                                                                                    =>
                                                                                    [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                 ::std::fmt::Display::fmt)],
                                                                                }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("hslog/mod.rs",
                                                         19u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        let result =
            set_logger(|max_log_level| {
                       max_log_level.set(LogLevelFilter::Trace);
                       Box::new(HSLogger{file: Mutex::new(file),}) });
        if let Err(e) = result {
            {
                $crate::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1({
                                                                               static __STATIC_FMTSTR:
                                                                                      &'static [&'static str]
                                                                                      =
                                                                                   &["Failed to initialize logger: "];
                                                                               __STATIC_FMTSTR
                                                                           },
                                                                           &match (&e,)
                                                                                {
                                                                                (__arg0,)
                                                                                =>
                                                                                [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                             ::std::fmt::Display::fmt)],
                                                                            }),
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("hslog/mod.rs", 28u32);
                                                &_FILE_LINE
                                            })
            };
        }
    }
    pub struct HSLogger {
        file: Mutex<File>,
    }
    impl Log for HSLogger {
        fn enabled(&self, metadata: &LogMetadata) -> bool {
            !(metadata.target().starts_with("gfx_device_gl"))
        }
        fn log(&self, record: &LogRecord) {
            if self.enabled(record.metadata()) {
                let mut file =
                    self.file.lock().expect("Failed to acquire lock on log file");
                let time = time::now();
                let result =
                    file.write_fmt(::std::fmt::Arguments::new_v1_formatted({
                                                                               static __STATIC_FMTSTR:
                                                                                      &'static [&'static str]
                                                                                      =
                                                                                   &["",
                                                                                     ":",
                                                                                     ":",
                                                                                     " [",
                                                                                     "] ",
                                                                                     ": ",
                                                                                     ""];
                                                                               __STATIC_FMTSTR
                                                                           },
                                                                           &match (&time.tm_hour,
                                                                                   &time.tm_min,
                                                                                   &time.tm_sec,
                                                                                   &record.level(),
                                                                                   &record.target(),
                                                                                   &record.args(),
                                                                                   &NEWLINE)
                                                                                {
                                                                                (__arg0,
                                                                                 __arg1,
                                                                                 __arg2,
                                                                                 __arg3,
                                                                                 __arg4,
                                                                                 __arg5,
                                                                                 __arg6)
                                                                                =>
                                                                                [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                             ::std::fmt::Display::fmt),
                                                                                 ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                             ::std::fmt::Display::fmt),
                                                                                 ::std::fmt::ArgumentV1::new(__arg2,
                                                                                                             ::std::fmt::Display::fmt),
                                                                                 ::std::fmt::ArgumentV1::new(__arg3,
                                                                                                             ::std::fmt::Display::fmt),
                                                                                 ::std::fmt::ArgumentV1::new(__arg4,
                                                                                                             ::std::fmt::Display::fmt),
                                                                                 ::std::fmt::ArgumentV1::new(__arg5,
                                                                                                             ::std::fmt::Display::fmt),
                                                                                 ::std::fmt::ArgumentV1::new(__arg6,
                                                                                                             ::std::fmt::Display::fmt)],
                                                                            },
                                                                           {
                                                                               static __STATIC_FMTARGS:
                                                                                      &'static [::std::fmt::rt::v1::Argument]
                                                                                      =
                                                                                   &[::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         8u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Is(2usize),},},
                                                                                     ::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         8u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Is(2usize),},},
                                                                                     ::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(2usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         8u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Is(2usize),},},
                                                                                     ::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(3usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         0u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,},},
                                                                                     ::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(4usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         0u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,},},
                                                                                     ::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(5usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         0u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,},},
                                                                                     ::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::At(6usize),
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         0u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,},}];
                                                                               __STATIC_FMTARGS
                                                                           }));
                if let Err(e) = result {
                    {
                        $crate::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1({
                                                                                       static __STATIC_FMTSTR:
                                                                                              &'static [&'static str]
                                                                                              =
                                                                                           &["Failed to write to log file: "];
                                                                                       __STATIC_FMTSTR
                                                                                   },
                                                                                   &match (&e,)
                                                                                        {
                                                                                        (__arg0,)
                                                                                        =>
                                                                                        [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                     ::std::fmt::Display::fmt)],
                                                                                    }),
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("hslog/mod.rs",
                                                             56u32);
                                                        &_FILE_LINE
                                                    })
                    };
                }
            }
        }
    }
}
#[macro_use]
mod entity {
    #[macro_use]
    pub mod modifiers {
        pub struct Modifier {
            pub value: f64,
            pub timer: usize,
            pub kind: ModifierKind,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Modifier {
            #[inline]
            fn clone(&self) -> Modifier {
                match *self {
                    Modifier {
                    value: ref __self_0_0,
                    timer: ref __self_0_1,
                    kind: ref __self_0_2 } =>
                    Modifier{value:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             timer:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             kind:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Modifier {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Modifier {
                    value: ref __self_0_0,
                    timer: ref __self_0_1,
                    kind: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Modifier");
                        let _ = builder.field("value", &&(*__self_0_0));
                        let _ = builder.field("timer", &&(*__self_0_1));
                        let _ = builder.field("kind", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[structural_match]
        pub enum ModifierKind { Additive, Multiplier, Multiplicative, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ModifierKind {
            #[inline]
            fn clone(&self) -> ModifierKind {
                match (&*self,) {
                    (&ModifierKind::Additive,) => ModifierKind::Additive,
                    (&ModifierKind::Multiplier,) => ModifierKind::Multiplier,
                    (&ModifierKind::Multiplicative,) =>
                    ModifierKind::Multiplicative,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ModifierKind {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&ModifierKind::Additive,) => {
                        let mut builder = __arg_0.debug_tuple("Additive");
                        builder.finish()
                    }
                    (&ModifierKind::Multiplier,) => {
                        let mut builder = __arg_0.debug_tuple("Multiplier");
                        builder.finish()
                    }
                    (&ModifierKind::Multiplicative,) => {
                        let mut builder =
                            __arg_0.debug_tuple("Multiplicative");
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for ModifierKind {
            #[inline]
            fn eq(&self, __arg_0: &ModifierKind) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for ModifierKind {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
        impl Modifier {
            pub fn update(&mut self) {
                if self.timer > 1 { self.timer -= 1; }
            }
            pub fn is_expired(&self) -> bool { self.timer == 1 }
        }
        pub fn apply(mods: &[Modifier], mut base: f64) -> f64 {
            let mut multiplier = 1.0;
            for modifier in
                mods.iter().filter(|m| m.kind == ModifierKind::Additive) {
                base += modifier.value;
            }
            for modifier in
                mods.iter().filter(|m| m.kind == ModifierKind::Multiplier) {
                multiplier += modifier.value;
            }
            for modifier in
                mods.iter().filter(|m| m.kind == ModifierKind::Multiplicative)
                {
                multiplier *= modifier.value;
            }
            base * multiplier
        }
    }
    pub mod entity_type {
        #[structural_match]
        pub enum EntityType {
            Player,
            Zombie,
            FlyingBallLinear,
            FlyingBallArc,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for EntityType {
            #[inline]
            fn clone(&self) -> EntityType {
                match (&*self,) {
                    (&EntityType::Player,) => EntityType::Player,
                    (&EntityType::Zombie,) => EntityType::Zombie,
                    (&EntityType::FlyingBallLinear,) =>
                    EntityType::FlyingBallLinear,
                    (&EntityType::FlyingBallArc,) =>
                    EntityType::FlyingBallArc,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for EntityType {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&EntityType::Player,) => {
                        let mut builder = __arg_0.debug_tuple("Player");
                        builder.finish()
                    }
                    (&EntityType::Zombie,) => {
                        let mut builder = __arg_0.debug_tuple("Zombie");
                        builder.finish()
                    }
                    (&EntityType::FlyingBallLinear,) => {
                        let mut builder =
                            __arg_0.debug_tuple("FlyingBallLinear");
                        builder.finish()
                    }
                    (&EntityType::FlyingBallArc,) => {
                        let mut builder =
                            __arg_0.debug_tuple("FlyingBallArc");
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for EntityType {
            #[inline]
            fn eq(&self, __arg_0: &EntityType) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for EntityType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
    }
    pub mod attack {
        use player::Player;
        use world::*;
        use entity::*;
        use items::*;
        use consts::balance::*;
        use hslog::*;
        #[allow(needless_borrow)]
        pub fn attack_melee_area(target_index: usize,
                                 entities: &mut Vec<Entity>,
                                 player: &mut Player) -> usize {
            let raw_entities = unsafe { &mut *(entities as *mut _) };
            let mut bounty = 0;
            let point;
            let range;
            let team;
            let multiplier;
            let weapon;
            {
                let entity = &entities[target_index];
                range = entity.current_weapon.range;
                team = entity.team.clone();
                point =
                    {
                        {
                            if entity.coords.ray(entity.current_weapon.range,
                                                 entity.direction.clone()).nth(1).can_unwrap()
                               {
                                entity.coords.ray(entity.current_weapon.range,
                                                  entity.direction.clone()).nth(1).unwrap()
                            } else {
                                {
                                    {
                                        static _LOC: $crate::LogLocation =
                                            $crate::LogLocation{__line: 23u32,
                                                                __file:
                                                                    "entity/attack.rs",
                                                                __module_path:
                                                                    "horde_survival::entity::attack",};
                                        let lvl = $crate::LogLevel::Error;
                                        if lvl <= $crate::__static_max_level()
                                               &&
                                               lvl <= $crate::max_log_level()
                                           {
                                            $crate::__log(lvl,
                                                          "horde_survival::entity::attack",
                                                          &_LOC,
                                                          ::std::fmt::Arguments::new_v1({
                                                                                            static __STATIC_FMTSTR:
                                                                                                   &'static [&'static str]
                                                                                                   =
                                                                                                &["Ray was deleted"];
                                                                                            __STATIC_FMTSTR
                                                                                        },
                                                                                        &match ()
                                                                                             {
                                                                                             ()
                                                                                             =>
                                                                                             [],
                                                                                         }))
                                        }
                                    };
                                    {
                                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("entity/attack.rs",
                                                                         23u32);
                                                                    &_FILE_LINE
                                                                })
                                    };
                                };
                            }
                        };
                    };
                multiplier = entity.get_damage();
                weapon = entity.current_weapon.clone();
            }
            let affected =
                entities.iter_mut().enumerate().filter(|&(_, ref e)| {
                                                       e.coords.in_radius(&point,
                                                                          range)
                                                           && e.team != team
                                                           && !e.is_dummy()
                                                   });
            for (i, e) in affected {
                e.damage(multiplier, i, target_index, raw_entities, player);
                if let Some(f) = weapon.on_hit {
                    f(target_index, i, raw_entities, player);
                }
                if e.is_dead() { bounty += e.bounty; }
            }
            bounty
        }
        pub fn attack_melee_line(target_index: usize,
                                 entities: &mut Vec<Entity>,
                                 player: &mut Player) -> usize {
            let mut bounty = 0;
            let raw_entities = unsafe { &mut *(entities as *mut _) };
            let multiplier;
            let coords;
            let direction;
            let weapon;
            {
                let entity = &entities[target_index];
                multiplier = entity.get_damage();
                coords = entity.coords.clone();
                direction = entity.direction;
                weapon = entity.current_weapon.clone();
            }
            let mut new = coords.clone();
            new.move_3d(direction, weapon.range);
            if let Some(e) =
                   get_collided_entity(target_index, &*entities, coords, new)
                   {
                let entity = &mut entities[e];
                entity.damage(multiplier, e, target_index, raw_entities,
                              player);
                if let Some(f) = weapon.on_hit {
                    f(target_index, e, raw_entities, player);
                }
                if entity.is_dead() { bounty = entity.bounty; }
            }
            bounty
        }
        pub fn attack_ranged_linear(target_index: usize,
                                    entities: &mut Vec<Entity>,
                                    next_id: &mut usize) -> usize {
            let mut dummy;
            {
                let entity = &entities[target_index];
                dummy =
                    Entity::new(*next_id, 1.0, 1.0,
                                entity.coords.translated(0.0,
                                                         PROJECTILE_SPAWN_OFFSET,
                                                         0.0),
                                EntityType::FlyingBallLinear,
                                entity.team.clone(), IsDummy::True,
                                entity.direction, RANGED_LINEAR_LIFETIME, 0,
                                HasGravity::False, HasAI::False,
                                Some(entity.id));
                *next_id += 1;
                dummy.as_mods.push({
                                       {
                                           Modifier{value:
                                                        entity.current_weapon.range,
                                                    timer: 0,
                                                    kind:
                                                        $crate::entity::modifiers::ModifierKind::Additive,}
                                       }
                                   });
            }
            entities.push(dummy);
            0
        }
        pub fn attack_ranged_projectile(target_index: usize,
                                        entities: &mut Vec<Entity>,
                                        next_id: &mut usize) -> usize {
            let mut dummy;
            {
                let entity = &entities[target_index];
                dummy =
                    Entity::new(*next_id, 1.0, 1.0,
                                entity.coords.translated(0.0,
                                                         PROJECTILE_SPAWN_OFFSET,
                                                         0.0),
                                EntityType::FlyingBallArc,
                                entity.team.clone(), IsDummy::True,
                                entity.direction, INFINITE_LIFETIME, 0,
                                HasGravity::False, HasAI::False,
                                Some(entity.id));
                *next_id += 1;
                let speed = entity.current_weapon.range * RANGED_ARC_SPEED;
                let angle = Direction(entity.direction.0 - 90.0).as_radians();
                dummy.velocity.accelerate(angle.cos() * speed,
                                          angle.sin() * speed);
            }
            entities.push(dummy);
            0
        }
        pub fn try_attack(id: usize, entities: &mut Vec<Entity>,
                          next_id: &mut usize, player: &mut Player) -> usize {
            let index =
                {
                    if entities.iter().enumerate().find(|&(_, e)|
                                                            e.id ==
                                                                id).can_unwrap()
                       {
                        entities.iter().enumerate().find(|&(_, e)|
                                                             e.id ==
                                                                 id).unwrap()
                    } else {
                        {
                            {
                                static _LOC: $crate::LogLocation =
                                    $crate::LogLocation{__line: 151u32,
                                                        __file:
                                                            "entity/attack.rs",
                                                        __module_path:
                                                            "horde_survival::entity::attack",};
                                let lvl = $crate::LogLevel::Error;
                                if lvl <= $crate::__static_max_level() &&
                                       lvl <= $crate::max_log_level() {
                                    $crate::__log(lvl,
                                                  "horde_survival::entity::attack",
                                                  &_LOC,
                                                  ::std::fmt::Arguments::new_v1({
                                                                                    static __STATIC_FMTSTR:
                                                                                           &'static [&'static str]
                                                                                           =
                                                                                        &["Entity not found: "];
                                                                                    __STATIC_FMTSTR
                                                                                },
                                                                                &match (&id,)
                                                                                     {
                                                                                     (__arg0,)
                                                                                     =>
                                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                  ::std::fmt::Display::fmt)],
                                                                                 }))
                                }
                            };
                            {
                                $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("entity/attack.rs",
                                                                 151u32);
                                                            &_FILE_LINE
                                                        })
                            };
                        };
                    }
                }.0;
            let weapon_type;
            let is_casting;
            {
                let entity = &mut entities[index];
                weapon_type = entity.current_weapon.weapon_type.clone();
                is_casting = entity.animations.is_casting(0);
                if !(entity.animations.can_attack() && !is_casting) &&
                       !is_casting {
                    return 0;
                }
                let attack_speed =
                    apply(&entity.as_mods,
                          entity.current_weapon.attack_speed);
                let attack_time =
                    entity.current_weapon.get_attack_time(attack_speed);
                let pre =
                    (entity.current_weapon.anim_pre as f64) * attack_time;
                let post =
                    (entity.current_weapon.anim_post as f64) * attack_time;
                entity.animations.start(0, pre as usize, post as usize);
            }
            if is_casting {
                match weapon_type {
                    WeaponType::MeleeArea =>
                    attack_melee_area(index, entities, player),
                    WeaponType::MeleeLine =>
                    attack_melee_line(index, entities, player),
                    WeaponType::RangedLinear =>
                    attack_ranged_linear(index, entities, next_id),
                    WeaponType::RangedProjectile =>
                    attack_ranged_projectile(index, entities, next_id),
                }
            } else { 0 }
        }
    }
    pub mod update {
        pub mod flying_ball {
            use consts::*;
            use entity::*;
            use entity::update::ai::calculate_error;
            use player::*;
            use world::*;
            use map::*;
            use hslog::CanUnwrap;
            pub fn update_flying_ball_linear(target_index: usize,
                                             entities: &mut Vec<Entity>,
                                             player: &mut Player) {
                let speed;
                {
                    let entity = &mut entities[target_index];
                    speed = entity.as_mods[0].value;
                    if entity.on_ground { entity.lifetime = 1; return; }
                }
                let old;
                let new;
                {
                    let entity = &mut entities[target_index];
                    old = entity.coords.clone();
                    entity.coords.move_3d(entity.direction,
                                          speed * RANGED_INTERVAL *
                                              RANGED_LINEAR_SPEED);
                    new = entity.coords.clone();
                }
                update_flying_ball(target_index, entities, old, new, player);
            }
            pub fn update_flying_ball_arc(target_index: usize,
                                          entities: &mut Vec<Entity>,
                                          player: &mut Player, map: &Map) {
                if entities[target_index].on_ground {
                    let mut found_target = true;
                    let spawned_by;
                    let projectile_coords;
                    let id;
                    let target_coords;
                    {
                        let entity = &entities[target_index];
                        spawned_by = entity.spawned_by;
                        projectile_coords = entity.coords.clone();
                        id = entity.id;
                        let target =
                            entities.iter().find(|e|
                                                     e.id ==
                                                         entity.ai_target_id);
                        match target {
                            Some(e) => target_coords = e.coords.clone(),
                            None => {
                                found_target = false;
                                target_coords = Coords::origin();
                            }
                        }
                    }
                    if found_target {
                        let source_id =
                            {
                                if spawned_by.can_unwrap() {
                                    spawned_by.unwrap()
                                } else {
                                    {
                                        {
                                            static _LOC: $crate::LogLocation =
                                                $crate::LogLocation{__line:
                                                                        71u32,
                                                                    __file:
                                                                        "entity/update/flying_ball.rs",
                                                                    __module_path:
                                                                        "horde_survival::entity::update::flying_ball",};
                                            let lvl = $crate::LogLevel::Error;
                                            if lvl <=
                                                   $crate::__static_max_level()
                                                   &&
                                                   lvl <=
                                                       $crate::max_log_level()
                                               {
                                                $crate::__log(lvl,
                                                              "horde_survival::entity::update::flying_ball",
                                                              &_LOC,
                                                              ::std::fmt::Arguments::new_v1({
                                                                                                static __STATIC_FMTSTR:
                                                                                                       &'static [&'static str]
                                                                                                       =
                                                                                                    &["Flying ball ID ",
                                                                                                      " has no source"];
                                                                                                __STATIC_FMTSTR
                                                                                            },
                                                                                            &match (&id,)
                                                                                                 {
                                                                                                 (__arg0,)
                                                                                                 =>
                                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                              ::std::fmt::Display::fmt)],
                                                                                             }))
                                            }
                                        };
                                        {
                                            $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("entity/update/flying_ball.rs",
                                                                             71u32);
                                                                        &_FILE_LINE
                                                                    })
                                        };
                                    };
                                }
                            };
                        let source =
                            entities.iter_mut().find(|e| e.id == source_id);
                        if let Some(e) = source {
                            if e.has_ai() {
                                let mut new_error =
                                    PROJECTILE_LEARNING_RATE *
                                        calculate_error(&e.coords,
                                                        &projectile_coords,
                                                        &target_coords);
                                new_error *=
                                    (0.5 / PROJECTILE_LEARNING_RATE).powi(4);
                                let increase =
                                    if e.ai_projectile_error > 0.0 {
                                        new_error - e.ai_projectile_error
                                    } else {
                                        e.ai_projectile_error - new_error
                                    };
                                if increase.abs() > ERROR_INCREASE_THRESHOLD {
                                    e.ai_consecutive_error_increases += 1;
                                }
                                e.ai_projectile_error += new_error;
                                if e.ai_consecutive_error_increases >
                                       ERROR_RESET_THRESHOLD {
                                    e.ai_consecutive_error_increases = 0;
                                    e.ai_projectile_error = 0.0;
                                }
                            }
                        }
                    }
                    entities[target_index].lifetime = 1;
                    return;
                }
                let old;
                let new;
                {
                    let entity = &mut entities[target_index];
                    old = entity.coords.clone();
                    let x_velocity =
                        entity.velocity.component_x * RANGED_ARC_SPEED;
                    entity.coords.move_forward(entity.direction.1,
                                               x_velocity as f64);
                    loop  {
                        if !entity.on_ground {
                            let mut coords = entity.coords.clone();
                            coords.translate(&Coords::new(0.0,
                                                          entity.velocity.component_y
                                                              *
                                                              RANGED_ARC_SPEED,
                                                          0.0));
                            let height = entity.get_height();
                            if map.test_collision(&coords, height) {
                                map.put_on_ground(&mut entity.coords, height);
                                entity.velocity = Velocity::zero();
                                break ;
                            }
                            entity.coords = coords;
                        }
                        break ;
                    }
                    entity.velocity.accelerate(0.0, -GRAVITY);
                    let rise = entity.velocity.component_y;
                    let run = entity.velocity.component_x;
                    entity.direction.0 = get_angle(rise, run);
                    new = entity.coords.clone();
                }
                update_flying_ball(target_index, entities, old, new, player);
            }
            pub fn update_flying_ball(target_index: usize,
                                      entities: &mut Vec<Entity>,
                                      old_pos: Coords, new_pos: Coords,
                                      player: &mut Player) -> bool {
                let raw_entities =
                    unsafe { &mut *(entities as *mut Vec<Entity>) };
                let collided =
                    get_collided_entity(target_index, entities, old_pos,
                                        new_pos);
                let hit;
                match collided {
                    Some(e) => {
                        let damage;
                        let id;
                        let weapon;
                        let index;
                        hit = true;
                        {
                            id =
                                {
                                    if entities[target_index].spawned_by.can_unwrap()
                                       {
                                        entities[target_index].spawned_by.unwrap()
                                    } else {
                                        {
                                            {
                                                static _LOC:
                                                       $crate::LogLocation =
                                                    $crate::LogLocation{__line:
                                                                            168u32,
                                                                        __file:
                                                                            "entity/update/flying_ball.rs",
                                                                        __module_path:
                                                                            "horde_survival::entity::update::flying_ball",};
                                                let lvl =
                                                    $crate::LogLevel::Error;
                                                if lvl <=
                                                       $crate::__static_max_level()
                                                       &&
                                                       lvl <=
                                                           $crate::max_log_level()
                                                   {
                                                    $crate::__log(lvl,
                                                                  "horde_survival::entity::update::flying_ball",
                                                                  &_LOC,
                                                                  ::std::fmt::Arguments::new_v1({
                                                                                                    static __STATIC_FMTSTR:
                                                                                                           &'static [&'static str]
                                                                                                           =
                                                                                                        &["Flying ball ID ",
                                                                                                          " has no source"];
                                                                                                    __STATIC_FMTSTR
                                                                                                },
                                                                                                &match (&entities[target_index].id,)
                                                                                                     {
                                                                                                     (__arg0,)
                                                                                                     =>
                                                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                  ::std::fmt::Display::fmt)],
                                                                                                 }))
                                                }
                                            };
                                            {
                                                $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                        {
                                                                            static _FILE_LINE:
                                                                                   (&'static str,
                                                                                    u32)
                                                                                   =
                                                                                ("entity/update/flying_ball.rs",
                                                                                 168u32);
                                                                            &_FILE_LINE
                                                                        })
                                            };
                                        };
                                    }
                                };
                            let result =
                                entities.iter().enumerate().find(|e|
                                                                     e.1.id ==
                                                                         id);
                            if let Some(r) = result {
                                let (i, entity) = r;
                                damage = entity.get_damage();
                                weapon = entity.current_weapon.clone();
                                index = i;
                            } else {
                                raw_entities[target_index].lifetime = 1;
                                return false;
                            }
                        }
                        let entity = &mut entities[e];
                        if entity.damage(damage, e, index, raw_entities,
                                         player) && id == player.entity_id {
                            player.give_gold(entity.bounty);
                        }
                        if let Some(f) = weapon.on_hit {
                            f(e, e, raw_entities, player);
                        }
                    }
                    None => { hit = false; }
                }
                if hit { entities[target_index].lifetime = 1; }
                hit
            }
        }
        pub mod player {
            use consts::{DEFAULT_MOUSE_SENSITIVITY, BASE_MOVESPEED};
            use world::*;
            use entity::{Entity, apply};
            use player::Player;
            use items::WeaponType;
            pub fn update_player(entity: &mut Entity, player: &mut Player)
             -> [bool; 4] {
                player.dead = entity.is_dead();
                if player.input.movement_key_pressed() {
                    let speed = apply(&entity.movespeed_mods, BASE_MOVESPEED);
                    let offset = player.input.movement_offset();
                    entity.move_forward(offset);
                    player.coords.move_forward(Direction(player.direction.1 +
                                                             offset).wrap().0,
                                               speed);
                }
                player.coords.y = entity.coords.y;
                let x = &mut entity.direction.0;
                let y = &mut entity.direction.1;
                let mut move_x =
                    DEFAULT_MOUSE_SENSITIVITY * (player.mouse.1 as f64);
                let move_y =
                    DEFAULT_MOUSE_SENSITIVITY * (player.mouse.0 as f64);
                player.direction.0 += move_x;
                player.direction.1 += move_y * -1.0;
                player.direction.1 = Direction(player.direction.1).wrap().0;
                if player.direction.0 < 1.0 {
                    player.direction.0 = 1.0
                } else if player.direction.0 > 179.0 {
                    player.direction.0 = 179.0
                }
                if let WeaponType::RangedProjectile =
                       entity.current_weapon.weapon_type {
                    move_x *= -1.0;
                }
                *x += move_x;
                *y += move_y * -1.0;
                *y = Direction(*y).wrap().0;
                if *x < 1.0 { *x = 1.0; } else if *x > 179.0 { *x = 179.0; }
                [entity.animations.is_casting(1),
                 entity.animations.is_casting(2),
                 entity.animations.is_casting(3),
                 entity.animations.is_casting(4)]
            }
        }
        pub mod ai {
            use world::Coords;
            use items::WeaponType;
            use entity::*;
            use consts::ai_control::*;
            pub fn apply_ai(target_index: usize, entities: &mut Vec<Entity>) {
                let closest = get_closest_entity(target_index, &*entities);
                if let Some((i, distance)) = closest {
                    let target_coords;
                    let target_id;
                    {
                        let entity = &entities[i];
                        target_coords = entity.coords.clone();
                        target_id = entity.id;
                    }
                    let entity = &mut entities[target_index];
                    let range = entity.current_weapon.get_real_range();
                    entity.direction =
                        entity.coords.direction_to(&target_coords);
                    if distance <= range {
                        entity.attack = true;
                        if let WeaponType::RangedProjectile =
                               entity.current_weapon.weapon_type {
                            if target_id != entity.ai_target_id {
                                entity.ai_projectile_error = 0.0;
                            }
                            entity.ai_target_id = target_id;
                            entity.direction.0 =
                                correct_for_error(entity.current_weapon.range,
                                                  entity.direction.0,
                                                  entity.ai_projectile_error);
                        }
                    }
                    if distance >= range * RANGE_THRESHOLD {
                        entity.move_forward(0.0);
                    } else if distance <= range * RANGE_TOO_CLOSE_THRESHOLD {
                        entity.move_forward(180.0);
                    }
                }
            }
            pub fn correct_for_error(speed: f64, angle: f64, error: f64)
             -> f64 {
                let corrected =
                    4.0 + angle + error * PROJECTILE_LEARNING_RATE / speed;
                if corrected < 45.0 {
                    45.0
                } else if corrected > 135.0 { 135.0 } else { corrected }
            }
            pub fn calculate_error(a: &Coords, b: &Coords, c: &Coords)
             -> f64 {
                let side_a = a.distance(b);
                let side_b = a.distance(c);
                let side_c = b.distance(c);
                let s = (side_a + side_b + side_c) / 2.0;
                let area =
                    ((s - side_a) * (s - side_b) * (s - side_c)).sqrt();
                let height = area / (side_a / 2.0);
                let side_d = (side_b.powi(2) - height.powi(2)).sqrt();
                if side_d - side_a > 0.0 { side_d } else { side_d * -1.0 }
            }
        }
        pub use self::flying_ball::*;
        pub use self::player::*;
        use consts::*;
        use player::*;
        use entity::modifiers::*;
        use entity::{Entity, EntityType};
        use world::*;
        use map::*;
        use self::ai::*;
        use entity::try_attack;
        pub fn update_entity(entities: &mut Vec<Entity>, index: usize,
                             map: &Map, player: &mut Player,
                             next_id: &mut usize) {
            let entity_type;
            let is_casting;
            let id;
            let coords;
            let attack;
            if entities[index].has_ai() { apply_ai(index, entities); }
            {
                let entity = &mut entities[index];
                entity_type = entity.entity_type.clone();
                id = entity.id;
                coords = entity.coords.clone();
                entity.update_hitbox();
                entity.on_ground =
                    map.test_collision(&entity.coords, entity.get_height());
                update_modifiers(&mut entity.damage_mods);
                update_modifiers(&mut entity.as_mods);
                update_modifiers(&mut entity.damage_taken_mods);
                update_modifiers(&mut entity.movespeed_mods);
                update_lifetime(&mut entity.lifetime);
                update_gravity(map, entity);
                if !entity.is_dummy() {
                    entity.animations.update();
                    is_casting = entity.animations.is_casting(0);
                } else { is_casting = false; }
                attack = entity.attack;
                entity.attack = false;
            }
            if is_casting || attack {
                let gold_gained = try_attack(id, entities, next_id, player);
                if id == player.entity_id { player.give_gold(gold_gained); }
            }
            match entity_type {
                EntityType::FlyingBallLinear => {
                    update_flying_ball_linear(index, entities, player);
                }
                EntityType::FlyingBallArc => {
                    update_flying_ball_arc(index, entities, player, map);
                }
                _ => { }
            }
            let entity = &mut entities[index];
            entity.needs_update =
                coords.distance(&entity.coords) > UPDATE_THRESHOLD;
        }
        pub fn update_modifiers(modifiers: &mut Vec<Modifier>) {
            *modifiers =
                modifiers.iter().cloned().filter(|m|
                                                     !m.is_expired()).collect();
            for modifier in modifiers { modifier.update(); }
        }
        pub fn update_lifetime(timer: &mut usize) {
            if *timer > 1 { *timer -= 1; }
        }
        pub fn update_gravity(map: &Map, entity: &mut Entity) {
            if entity.has_gravity() {
                let mut coords = entity.coords.clone();
                coords.translate(&Coords::new(0.0,
                                              entity.velocity.component_y,
                                              0.0));
                let height = entity.get_height();
                if map.test_collision(&coords, height) {
                    map.put_on_ground(&mut entity.coords, height);
                    entity.velocity.component_y = 0.0;
                    return;
                }
                entity.coords = coords;
                entity.velocity.accelerate(0.0, -GRAVITY);
            }
        }
    }
    pub mod filter {
        use collision::{Ray, Intersect};
        use entity::{Entity, EntityType};
        use world::Coords;
        pub fn filter_entities(entities: &mut Vec<Entity>) {
            *entities =
                entities.iter().cloned().filter(|e| {
                                                let result =
                                                    if e.entity_type ==
                                                           EntityType::Player
                                                           || e.is_dummy() {
                                                        true
                                                    } else { !e.is_dead() };
                                                result && !(e.lifetime == 1)
                                            }).collect();
        }
        pub fn get_closest_entity(index: usize, entities: &[Entity])
         -> Option<(usize, f64)> {
            let entity = &entities[index];
            let mut closest_index = 0;
            let mut closest_distance = None;
            for (i, e) in entities.iter().enumerate() {
                if e.is_dummy() || !e.is_enemy_of(entity) { continue ; }
                let distance = e.coords.distance(&entity.coords);
                if let Some(ref mut d) = closest_distance {
                    if distance < *d { *d = distance; closest_index = i; }
                } else {
                    closest_distance = Some(distance);
                    closest_index = i;
                }
            }
            if let Some(d) = closest_distance {
                Some((closest_index, d))
            } else { None }
        }
        pub fn get_collided_entity(projectile_index: usize,
                                   entities: &[Entity], old_pos: Coords,
                                   new_pos: Coords) -> Option<usize> {
            let distance = old_pos.distance(&new_pos);
            let diff =
                Coords::new(new_pos.x - old_pos.x, new_pos.y - old_pos.y,
                            new_pos.z - old_pos.z).as_vector();
            let ray = Ray::new(old_pos.as_point(), diff);
            let entity = &entities[projectile_index];
            for (i, e) in entities.iter().enumerate() {
                if e.is_dummy() || !e.is_enemy_of(entity) { continue ; }
                let intersection = (ray, e.hitbox).intersection();
                if let Some(p) = intersection {
                    if old_pos.distance(&Coords::new(p.x, p.y, p.z)) <=
                           distance {
                        return Some(i);
                    }
                }
            }
            None
        }
    }
    pub mod flags {
        #[structural_match]
        pub enum HasGravity { True, False, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for HasGravity {
            #[inline]
            fn clone(&self) -> HasGravity {
                match (&*self,) {
                    (&HasGravity::True,) => HasGravity::True,
                    (&HasGravity::False,) => HasGravity::False,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for HasGravity {
            #[inline]
            fn eq(&self, __arg_0: &HasGravity) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for HasGravity {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
        #[structural_match]
        pub enum HasAI { True, False, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for HasAI {
            #[inline]
            fn clone(&self) -> HasAI {
                match (&*self,) {
                    (&HasAI::True,) => HasAI::True,
                    (&HasAI::False,) => HasAI::False,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for HasAI {
            #[inline]
            fn eq(&self, __arg_0: &HasAI) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for HasAI {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
        #[structural_match]
        pub enum IsDummy { True, False, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for IsDummy {
            #[inline]
            fn clone(&self) -> IsDummy {
                match (&*self,) {
                    (&IsDummy::True,) => IsDummy::True,
                    (&IsDummy::False,) => IsDummy::False,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for IsDummy {
            #[inline]
            fn eq(&self, __arg_0: &IsDummy) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for IsDummy {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
        #[structural_match]
        pub enum Team { Players, Monsters, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Team {
            #[inline]
            fn clone(&self) -> Team {
                match (&*self,) {
                    (&Team::Players,) => Team::Players,
                    (&Team::Monsters,) => Team::Monsters,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Team {
            #[inline]
            fn eq(&self, __arg_0: &Team) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Team {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
    }
    pub mod animation {
        #[rustc_copy_clone_marker]
        struct Animation {
            post: usize,
            timer: usize,
            state: AnimationState,
            casting: bool,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Animation {
            #[inline]
            fn clone(&self) -> Animation {
                {
                    let _: ::std::clone::AssertParamIsClone<usize>;
                    let _: ::std::clone::AssertParamIsClone<usize>;
                    let _: ::std::clone::AssertParamIsClone<AnimationState>;
                    let _: ::std::clone::AssertParamIsClone<bool>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Animation { }
        #[rustc_copy_clone_marker]
        enum AnimationState { Pre, Post, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for AnimationState {
            #[inline]
            fn clone(&self) -> AnimationState { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for AnimationState { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for AnimationState {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&AnimationState::Pre,) => {
                        let mut builder = __arg_0.debug_tuple("Pre");
                        builder.finish()
                    }
                    (&AnimationState::Post,) => {
                        let mut builder = __arg_0.debug_tuple("Post");
                        builder.finish()
                    }
                }
            }
        }
        pub struct AnimationList {
            list: [Animation; 5],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for AnimationList {
            #[inline]
            fn clone(&self) -> AnimationList {
                match *self {
                    AnimationList { list: ref __self_0_0 } =>
                    AnimationList{list:
                                      ::std::clone::Clone::clone(&(*__self_0_0)),},
                }
            }
        }
        impl Animation {
            pub fn new() -> Animation {
                Animation{post: 0,
                          timer: 0,
                          state: AnimationState::Pre,
                          casting: false,}
            }
            pub fn update(&mut self) {
                self.casting = false;
                match self.state {
                    AnimationState::Pre => {
                        if self.timer == 1 {
                            self.timer = self.post;
                            self.state = AnimationState::Post;
                            self.casting = true;
                        }
                    }
                    AnimationState::Post => {
                        if self.timer == 0 {
                            self.state = AnimationState::Pre;
                            self.casting = false;
                        }
                    }
                }
                if self.timer > 0 { self.timer -= 1; }
            }
            pub fn can_cast(&self) -> bool {
                match self.state {
                    AnimationState::Pre => self.timer == 0,
                    AnimationState::Post => false,
                }
            }
            pub fn start(&mut self, pre: usize, post: usize) {
                self.timer = pre + 1;
                self.post = post;
            }
            pub fn is_casting(&self) -> bool { self.casting }
        }
        impl AnimationList {
            pub fn new() -> AnimationList {
                AnimationList{list: [Animation::new(); 5],}
            }
            pub fn update(&mut self) {
                for animation in &mut self.list { animation.update(); }
            }
            pub fn can_cast(&self, id: usize) -> bool {
                self.list[id].can_cast()
            }
            pub fn can_attack(&self) -> bool { self.list[0].can_cast() }
            pub fn start(&mut self, id: usize, pre: usize, post: usize) {
                self.list[id].start(pre, post);
            }
            pub fn is_casting(&self, id: usize) -> bool {
                self.list[id].is_casting()
            }
        }
    }
    pub use self::entity_type::EntityType;
    pub use self::modifiers::*;
    pub use self::attack::try_attack;
    pub use self::update::*;
    pub use self::filter::*;
    pub use self::flags::*;
    pub use self::animation::*;
    use collision::Aabb3;
    use consts::balance::*;
    use items::*;
    use world::*;
    use player::Player;
    pub type Hitbox = Aabb3<f64>;
    pub struct Entity {
        pub id: usize,
        pub health: f64,
        pub max_hp: f64,
        pub entity_type: EntityType,
        pub coords: Coords,
        pub direction: (f64, f64),
        pub velocity: Velocity,
        pub damage_mods: Vec<Modifier>,
        pub as_mods: Vec<Modifier>,
        pub damage_taken_mods: Vec<Modifier>,
        pub movespeed_mods: Vec<Modifier>,
        pub has_gravity: HasGravity,
        pub on_ground: bool,
        pub hitbox: Hitbox,
        pub has_ai: HasAI,
        pub team: Team,
        pub is_dummy: IsDummy,
        pub armor: [Armor; 4],
        pub current_weapon: Weapon,
        pub animations: AnimationList,
        pub lifetime: usize,
        pub spawned_by: Option<usize>,
        pub bounty: usize,
        pub needs_update: bool,
        pub attack: bool,
        pub ai_projectile_error: f64,
        pub ai_target_id: usize,
        pub ai_consecutive_error_increases: usize,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            match *self {
                Entity {
                id: ref __self_0_0,
                health: ref __self_0_1,
                max_hp: ref __self_0_2,
                entity_type: ref __self_0_3,
                coords: ref __self_0_4,
                direction: ref __self_0_5,
                velocity: ref __self_0_6,
                damage_mods: ref __self_0_7,
                as_mods: ref __self_0_8,
                damage_taken_mods: ref __self_0_9,
                movespeed_mods: ref __self_0_10,
                has_gravity: ref __self_0_11,
                on_ground: ref __self_0_12,
                hitbox: ref __self_0_13,
                has_ai: ref __self_0_14,
                team: ref __self_0_15,
                is_dummy: ref __self_0_16,
                armor: ref __self_0_17,
                current_weapon: ref __self_0_18,
                animations: ref __self_0_19,
                lifetime: ref __self_0_20,
                spawned_by: ref __self_0_21,
                bounty: ref __self_0_22,
                needs_update: ref __self_0_23,
                attack: ref __self_0_24,
                ai_projectile_error: ref __self_0_25,
                ai_target_id: ref __self_0_26,
                ai_consecutive_error_increases: ref __self_0_27 } =>
                Entity{id: ::std::clone::Clone::clone(&(*__self_0_0)),
                       health: ::std::clone::Clone::clone(&(*__self_0_1)),
                       max_hp: ::std::clone::Clone::clone(&(*__self_0_2)),
                       entity_type:
                           ::std::clone::Clone::clone(&(*__self_0_3)),
                       coords: ::std::clone::Clone::clone(&(*__self_0_4)),
                       direction: ::std::clone::Clone::clone(&(*__self_0_5)),
                       velocity: ::std::clone::Clone::clone(&(*__self_0_6)),
                       damage_mods:
                           ::std::clone::Clone::clone(&(*__self_0_7)),
                       as_mods: ::std::clone::Clone::clone(&(*__self_0_8)),
                       damage_taken_mods:
                           ::std::clone::Clone::clone(&(*__self_0_9)),
                       movespeed_mods:
                           ::std::clone::Clone::clone(&(*__self_0_10)),
                       has_gravity:
                           ::std::clone::Clone::clone(&(*__self_0_11)),
                       on_ground: ::std::clone::Clone::clone(&(*__self_0_12)),
                       hitbox: ::std::clone::Clone::clone(&(*__self_0_13)),
                       has_ai: ::std::clone::Clone::clone(&(*__self_0_14)),
                       team: ::std::clone::Clone::clone(&(*__self_0_15)),
                       is_dummy: ::std::clone::Clone::clone(&(*__self_0_16)),
                       armor: ::std::clone::Clone::clone(&(*__self_0_17)),
                       current_weapon:
                           ::std::clone::Clone::clone(&(*__self_0_18)),
                       animations:
                           ::std::clone::Clone::clone(&(*__self_0_19)),
                       lifetime: ::std::clone::Clone::clone(&(*__self_0_20)),
                       spawned_by:
                           ::std::clone::Clone::clone(&(*__self_0_21)),
                       bounty: ::std::clone::Clone::clone(&(*__self_0_22)),
                       needs_update:
                           ::std::clone::Clone::clone(&(*__self_0_23)),
                       attack: ::std::clone::Clone::clone(&(*__self_0_24)),
                       ai_projectile_error:
                           ::std::clone::Clone::clone(&(*__self_0_25)),
                       ai_target_id:
                           ::std::clone::Clone::clone(&(*__self_0_26)),
                       ai_consecutive_error_increases:
                           ::std::clone::Clone::clone(&(*__self_0_27)),},
            }
        }
    }
    impl Entity {
        #[allow(too_many_arguments)]
        pub fn new(id: usize, health: f64, max_hp: f64, coords: Coords,
                   entity_type: EntityType, team: Team, is_dummy: IsDummy,
                   direction: (f64, f64), lifetime: usize, bounty: usize,
                   has_gravity: HasGravity, has_ai: HasAI,
                   spawned_by: Option<usize>) -> Entity {
            let hitbox = get_hitbox(&entity_type, &coords);
            let mut movespeed_mods = Vec::new();
            let movespeed = get_movespeed(&entity_type);
            if let Some(m) = movespeed {
                movespeed_mods.push({
                                        {
                                            Modifier{value: m,
                                                     timer: 0,
                                                     kind:
                                                         $crate::entity::modifiers::ModifierKind::Multiplicative,}
                                        }
                                    });
            }
            Entity{id: id,
                   coords: coords,
                   hitbox: hitbox,
                   entity_type: entity_type,
                   direction: direction,
                   health: health,
                   max_hp: max_hp,
                   animations: AnimationList::new(),
                   damage_mods: Vec::new(),
                   as_mods: Vec::new(),
                   damage_taken_mods: Vec::new(),
                   movespeed_mods: movespeed_mods,
                   team: team,
                   is_dummy: is_dummy,
                   lifetime: lifetime,
                   velocity: Velocity::zero(),
                   has_gravity: has_gravity,
                   on_ground: false,
                   has_ai: has_ai,
                   current_weapon: UNARMED,
                   armor: [HEAD_NONE, BODY_NONE, LEGS_NONE, FEET_NONE],
                   spawned_by: spawned_by,
                   ai_projectile_error: 0.0,
                   ai_target_id: 0,
                   ai_consecutive_error_increases: 0,
                   bounty: bounty,
                   needs_update: true,
                   attack: false,}
        }
    }
    impl Entity {
        pub fn player(coords: Coords, entity_id: usize, team: Team)
         -> Entity {
            Entity::new(entity_id, PLAYER_HEALTH, PLAYER_HEALTH, coords,
                        EntityType::Player, team, IsDummy::False,
                        DEFAULT_DIRECTION, INFINITE_LIFETIME, 0,
                        HasGravity::True, HasAI::False, None)
        }
        pub fn monster(entity_type: EntityType, coords: Coords,
                       entity_id: usize, team: Team, bounty: usize)
         -> Entity {
            let health = get_monster_health(&entity_type);
            Entity::new(entity_id, health, health, coords, entity_type, team,
                        IsDummy::False, DEFAULT_DIRECTION, INFINITE_LIFETIME,
                        bounty, HasGravity::True, HasAI::True, None)
        }
    }
    impl Entity {
        #[allow(dead_code)]
        pub fn heal(&mut self, amount: f64) {
            self.health += amount;
            if self.health > self.max_hp { self.health = self.max_hp; }
        }
        pub fn damage(&mut self, mut damage: f64, self_index: usize,
                      hit_by: usize, entities: &mut Vec<Entity>,
                      player: &mut Player) -> bool {
            for armor in &mut self.armor {
                if let Some(f) = armor.when_hit {
                    f(self_index, hit_by, entities, player);
                    damage *= armor.multiplier;
                }
            }
            self.health -= apply(&self.damage_taken_mods, damage);
            self.is_dead()
        }
        pub fn get_damage(&self) -> f64 {
            apply(&self.damage_mods, self.current_weapon.damage)
        }
        pub fn move_forward(&mut self, movement_offset: f64) {
            let speed = apply(&self.movespeed_mods, BASE_MOVESPEED);
            self.coords.move_forward(self.direction.1 + movement_offset,
                                     speed);
        }
        pub fn kill(&mut self) { self.health = DEAD_ENTITY_HEALTH; }
        pub fn update_hitbox(&mut self) {
            self.hitbox = get_hitbox(&self.entity_type, &self.coords);
        }
        pub fn get_height(&self) -> f64 {
            self.hitbox.max.y - self.hitbox.min.y
        }
        pub fn is_monster(&self) -> bool {
            match self.entity_type { EntityType::Zombie => true, _ => false, }
        }
    }
    impl Entity {
        pub fn is_dead(&self) -> bool { self.health <= 0.0 }
        pub fn is_enemy_of(&self, other: &Entity) -> bool {
            self.team != other.team
        }
        pub fn is_dummy(&self) -> bool { self.is_dummy == IsDummy::True }
        pub fn has_ai(&self) -> bool { self.has_ai == HasAI::True }
        pub fn has_gravity(&self) -> bool {
            self.has_gravity == HasGravity::True
        }
    }
}
#[macro_use]
mod items {
    pub mod weapon {
        use random_choice::random_choice;
        use consts::*;
        use items::effects::*;
        use std::usize;
        pub struct Weapon {
            pub name: &'static str,
            pub damage: f64,
            pub range: f64,
            pub attack_speed: f64,
            pub anim_pre: usize,
            pub anim_post: usize,
            pub weapon_type: WeaponType,
            pub on_hit: Option<ItemEffect>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Weapon {
            #[inline]
            fn clone(&self) -> Weapon {
                match *self {
                    Weapon {
                    name: ref __self_0_0,
                    damage: ref __self_0_1,
                    range: ref __self_0_2,
                    attack_speed: ref __self_0_3,
                    anim_pre: ref __self_0_4,
                    anim_post: ref __self_0_5,
                    weapon_type: ref __self_0_6,
                    on_hit: ref __self_0_7 } =>
                    Weapon{name: ::std::clone::Clone::clone(&(*__self_0_0)),
                           damage: ::std::clone::Clone::clone(&(*__self_0_1)),
                           range: ::std::clone::Clone::clone(&(*__self_0_2)),
                           attack_speed:
                               ::std::clone::Clone::clone(&(*__self_0_3)),
                           anim_pre:
                               ::std::clone::Clone::clone(&(*__self_0_4)),
                           anim_post:
                               ::std::clone::Clone::clone(&(*__self_0_5)),
                           weapon_type:
                               ::std::clone::Clone::clone(&(*__self_0_6)),
                           on_hit:
                               ::std::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        pub enum WeaponType {
            MeleeLine,
            MeleeArea,
            RangedLinear,
            RangedProjectile,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for WeaponType {
            #[inline]
            fn clone(&self) -> WeaponType {
                match (&*self,) {
                    (&WeaponType::MeleeLine,) => WeaponType::MeleeLine,
                    (&WeaponType::MeleeArea,) => WeaponType::MeleeArea,
                    (&WeaponType::RangedLinear,) => WeaponType::RangedLinear,
                    (&WeaponType::RangedProjectile,) =>
                    WeaponType::RangedProjectile,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for WeaponType {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&WeaponType::MeleeLine,) => {
                        let mut builder = __arg_0.debug_tuple("MeleeLine");
                        builder.finish()
                    }
                    (&WeaponType::MeleeArea,) => {
                        let mut builder = __arg_0.debug_tuple("MeleeArea");
                        builder.finish()
                    }
                    (&WeaponType::RangedLinear,) => {
                        let mut builder = __arg_0.debug_tuple("RangedLinear");
                        builder.finish()
                    }
                    (&WeaponType::RangedProjectile,) => {
                        let mut builder =
                            __arg_0.debug_tuple("RangedProjectile");
                        builder.finish()
                    }
                }
            }
        }
        impl Weapon {
            pub fn get_real_range(&self) -> f64 {
                match self.weapon_type {
                    WeaponType::MeleeLine =>
                    self.range * MELEE_LINE_INTERVAL * MELEE_LINE_RADIUS *
                        2.0,
                    WeaponType::MeleeArea => self.range * 2.0,
                    WeaponType::RangedLinear =>
                    ((self.range + 1.0) * RANGED_INTERVAL *
                         (RANGED_LINEAR_LIFETIME as f64)).powf(0.75),
                    WeaponType::RangedProjectile =>
                    (self.range * (0.1 / GRAVITY)).powf(0.4),
                }
            }
            pub fn get_attack_time(&self, attack_speed: f64) -> f64 {
                let x = 1.0 / attack_speed;
                x * GLOBAL_ATTACK_TIME
            }
        }
        pub fn get_random_monster_weapon(wave: usize) -> Weapon {
            let items = [UNARMED, TEST_SWORD, TEST_WAND, TEST_BOW, TEST_GUN];
            let weights = [1.0, 1.0, 1.0, 1.0, 1.0];
            let mut rng = random_choice();
            let range =
                match wave {
                    9 ...11 => ..4,
                    6 ...8 => ..3,
                    3 ...5 => ..2,
                    0 ...2 => ..1,
                    _ => ..items.len(),
                };
            rng.random_choice_f64(&items[range], &weights[range],
                                  1)[0].clone()
        }
    }
    pub mod armor {
        use items::effects::*;
        #[rustc_copy_clone_marker]
        pub struct Armor {
            pub name: &'static str,
            pub multiplier: f64,
            pub when_hit: Option<ItemEffect>,
            pub slot: ArmorSlot,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Armor {
            #[inline]
            fn clone(&self) -> Armor {
                {
                    let _: ::std::clone::AssertParamIsClone<&'static str>;
                    let _: ::std::clone::AssertParamIsClone<f64>;
                    let _:
                            ::std::clone::AssertParamIsClone<Option<ItemEffect>>;
                    let _: ::std::clone::AssertParamIsClone<ArmorSlot>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Armor { }
        impl Armor {
            pub fn is_none(&self) -> bool { self.name == "None" }
        }
        #[rustc_copy_clone_marker]
        pub enum ArmorSlot { Head, Body, Legs, Feet, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ArmorSlot {
            #[inline]
            fn clone(&self) -> ArmorSlot { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for ArmorSlot { }
    }
    pub mod effects {
        #![allow(dead_code, unused_variables)]
        pub mod armor {
            use rand::{Rng, thread_rng};
            use consts::balance::items::effects::*;
            use entity::*;
            use player::Player;
            pub fn armor_effect_heal(entity_index: usize, hit_by: usize,
                                     entities: &mut Vec<Entity>,
                                     player: &mut Player) {
                if thread_rng().gen_range(0, ARMOR_EFFECT_HEAL_RANGE) == 0 {
                    entities[entity_index].heal(ARMOR_EFFECT_HEAL_AMOUNT);
                }
            }
        }
        pub mod weapon {
            use rand::{Rng, thread_rng};
            use consts::*;
            use entity::*;
            use player::Player;
            pub fn weapon_effect_instant_kill_10(entity_index: usize,
                                                 being_hit: usize,
                                                 entities: &mut Vec<Entity>,
                                                 player: &mut Player) {
                if thread_rng().gen_range(0,
                                          WEAPON_EFFECT_LIGHTNING_SWORD_2_RANGE)
                       == 0 {
                    let entity = &mut entities[being_hit];
                    player.give_gold(entity.bounty);
                    entity.kill();
                }
            }
        }
        use entity::Entity;
        use player::Player;
        pub type ItemEffect =
            &'static Fn(usize, usize, &mut Vec<Entity>, &mut Player);
    }
    pub mod shop {
        use items::Item;
        pub struct ShopItem {
            pub item: &'static Item,
            pub price: usize,
        }
    }
    #[macro_use]
    pub mod macros { }
    pub use self::weapon::*;
    pub use self::armor::*;
    pub use self::effects::weapon::*;
    pub use self::effects::armor::*;
    pub use self::shop::*;
    pub enum Item { Weapon(Weapon), Armor(Armor), }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Item {
        #[inline]
        fn clone(&self) -> Item {
            match (&*self,) {
                (&Item::Weapon(ref __self_0),) =>
                Item::Weapon(::std::clone::Clone::clone(&(*__self_0))),
                (&Item::Armor(ref __self_0),) =>
                Item::Armor(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
}
#[macro_use]
mod hsgraphics {
    #[macro_use]
    pub mod shapes {
        #[macro_use]
        pub mod shapes2d { }
        pub mod shapes3d {
            use consts::scale::WORLD_SCALE;
            use hsgraphics::gfx3d::Vertex;
            pub fn cube(position: [f32; 3], size: f32)
             -> ([Vertex; 24], [u16; 36]) {
                let mut v =
                    [[1.0, 1.0, 1.0], [1.0, 1.0, -1.0], [-1.0, 1.0, 1.0],
                     [-1.0, 1.0, -1.0], [1.0, -1.0, 1.0], [-1.0, -1.0, 1.0],
                     [1.0, -1.0, -1.0], [-1.0, -1.0, -1.0]];
                for pos in &mut v {
                    for (i, c) in pos[0..3].iter_mut().enumerate() {
                        *c =
                            position[i] * WORLD_SCALE +
                                *c * WORLD_SCALE * size;
                    }
                }
                let vertex_data =
                    [Vertex::new(v[5], [0.0, 0.0]),
                     Vertex::new(v[4], [1.0, 0.0]),
                     Vertex::new(v[0], [1.0, 1.0]),
                     Vertex::new(v[2], [0.0, 1.0]),
                     Vertex::new(v[3], [1.0, 0.0]),
                     Vertex::new(v[1], [0.0, 0.0]),
                     Vertex::new(v[6], [0.0, 1.0]),
                     Vertex::new(v[7], [1.0, 1.0]),
                     Vertex::new(v[6], [0.0, 0.0]),
                     Vertex::new(v[1], [1.0, 0.0]),
                     Vertex::new(v[0], [1.0, 1.0]),
                     Vertex::new(v[4], [0.0, 1.0]),
                     Vertex::new(v[5], [1.0, 0.0]),
                     Vertex::new(v[2], [0.0, 0.0]),
                     Vertex::new(v[3], [0.0, 1.0]),
                     Vertex::new(v[7], [1.0, 1.0]),
                     Vertex::new(v[1], [1.0, 0.0]),
                     Vertex::new(v[3], [0.0, 0.0]),
                     Vertex::new(v[2], [0.0, 1.0]),
                     Vertex::new(v[0], [1.0, 1.0]),
                     Vertex::new(v[4], [0.0, 0.0]),
                     Vertex::new(v[5], [1.0, 0.0]),
                     Vertex::new(v[7], [1.0, 1.0]),
                     Vertex::new(v[6], [0.0, 1.0])];
                let index_data =
                    [0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4, 8, 9, 10, 10, 11, 8,
                     12, 13, 14, 14, 15, 12, 16, 17, 18, 18, 19, 16, 20, 21,
                     22, 22, 23, 20];
                (vertex_data, index_data)
            }
            pub fn plane(height: f32, size: f32) -> ([Vertex; 4], [u16; 6]) {
                let mut vertex_data =
                    [Vertex::new([-0.5, -0.5, height], [0.0, 0.0]),
                     Vertex::new([0.5, -0.5, height], [1.0, 0.0]),
                     Vertex::new([0.5, 0.5, height], [1.0, 1.0]),
                     Vertex::new([-0.5, 0.5, height], [0.0, 1.0])];
                let index_data = [0, 1, 2, 2, 3, 0];
                for pos in vertex_data.iter_mut().map(|v| &mut v.pos) {
                    pos[0] *= WORLD_SCALE * size;
                    pos[1] *= WORLD_SCALE * size;
                }
                (vertex_data, index_data)
            }
        }
    }
    pub mod state {
        use gfx::Device;
        use glutin::Window;
        use cgmath::Matrix4;
        use gfx_device_gl;
        use hsgraphics::object2d::Object2d;
        use hsgraphics::object3d::*;
        use hsgraphics::*;
        use gamestate::GameState;
        use assets::AssetLoader;
        use world::Coords;
        use hslog::CanUnwrap;
        use consts::*;
        pub struct GraphicsState {
            pub options: GraphicsOptions,
            pub window_size: (u32, u32),
            pub window_center: (i32, i32),
            pub aspect_ratio: f32,
            pub factory: gfx_device_gl::Factory,
            pub encoder: ObjectEncoder,
            pub device: gfx_device_gl::Device,
            pub should_close: bool,
            pub objects2d: Vec<Object2d>,
            pub objects3d: Vec<Object3d>,
            pub pso2d: object2d::ObjectPSO,
            pub pso3d: object3d::ObjectPSO,
            pub pso_gui: gfx_gui::Pso,
            pub data: gfx3d::pipe::Data<gfx_device_gl::Resources>,
            pub data2d: gfx2d::pipe::Data<gfx_device_gl::Resources>,
            pub data_gui: gfx_gui::pipe::Data<gfx_device_gl::Resources>,
            pub cache: TextCache,
            pub assets: AssetLoader<String>,
            pub last_cursor_pos: (i32, i32),
            pub camera: Matrix4<f32>,
            pub pixel_size: (f32, f32),
            pub dpi: f32,
        }
        impl GraphicsState {
            pub fn draw(&mut self, window: &Window) {
                self.encoder.clear(&self.data.out_color, CLEAR_COLOR);
                self.encoder.clear_depth(&self.data.out_depth, 1.0);
                self.encode_objects3d();
                self.encode_objects2d();
                self.encoder.flush(&mut self.device);
                if let Err(e) = window.swap_buffers() {
                    {
                        static _LOC: $crate::LogLocation =
                            $crate::LogLocation{__line: 65u32,
                                                __file: "hsgraphics/state.rs",
                                                __module_path:
                                                    "horde_survival::hsgraphics::state",};
                        let lvl = $crate::LogLevel::Error;
                        if lvl <= $crate::__static_max_level() &&
                               lvl <= $crate::max_log_level() {
                            $crate::__log(lvl,
                                          "horde_survival::hsgraphics::state",
                                          &_LOC,
                                          ::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["Failed to swap buffers: "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&e,)
                                                                             {
                                                                             (__arg0,)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         }))
                        }
                    };
                }
                self.device.cleanup();
            }
            pub fn update(&mut self, game: &GameState) {
                self.update_crosshair();
                self.update_entity_objects(&game.entities,
                                           game.player.entity_id);
            }
            pub fn draw_gui(&mut self, window: &Window) {
                self.encoder.flush(&mut self.device);
                if let Err(e) = window.swap_buffers() {
                    {
                        static _LOC: $crate::LogLocation =
                            $crate::LogLocation{__line: 80u32,
                                                __file: "hsgraphics/state.rs",
                                                __module_path:
                                                    "horde_survival::hsgraphics::state",};
                        let lvl = $crate::LogLevel::Error;
                        if lvl <= $crate::__static_max_level() &&
                               lvl <= $crate::max_log_level() {
                            $crate::__log(lvl,
                                          "horde_survival::hsgraphics::state",
                                          &_LOC,
                                          ::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["Failed to swap buffers: "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&e,)
                                                                             {
                                                                             (__arg0,)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         }))
                        }
                    };
                }
                self.device.cleanup();
            }
            pub fn update_camera(&mut self, coords: Coords,
                                 direction: (f64, f64)) {
                self.camera =
                    get_camera(coords, direction, self.aspect_ratio);
                let locals = gfx3d::Locals{transform: self.camera.into(),};
                self.encoder.update_constant_buffer(&self.data.locals,
                                                    &locals);
            }
            pub fn update_dpi(&mut self, window: &Window) {
                self.dpi = window.hidpi_factor();
            }
            pub fn update_crosshair(&mut self) {
                self.remove_objects2d(CROSSHAIR_OBJECT_ID);
                if self.options.crosshair {
                    let mut vertices =
                        {
                            [$crate::hsgraphics::gfx2d::Vertex::new([1.0,
                                                                     0.0],
                                                                    [1.0,
                                                                     0.0]),
                             $crate::hsgraphics::gfx2d::Vertex::new([0.0,
                                                                     1.0],
                                                                    [0.0,
                                                                     1.0]),
                             $crate::hsgraphics::gfx2d::Vertex::new([-1.0,
                                                                     0.0],
                                                                    [1.0,
                                                                     1.0]),
                             $crate::hsgraphics::gfx2d::Vertex::new([1.0,
                                                                     0.0],
                                                                    [1.0,
                                                                     0.0]),
                             $crate::hsgraphics::gfx2d::Vertex::new([-1.0,
                                                                     0.0],
                                                                    [1.0,
                                                                     1.0]),
                             $crate::hsgraphics::gfx2d::Vertex::new([0.0,
                                                                     -1.0],
                                                                    [0.0,
                                                                     0.0])]
                        };
                    let (scale_x, scale_y) =
                        (CROSSHAIR_SIZE / (self.window_size.0 as f32),
                         CROSSHAIR_SIZE / (self.window_size.1 as f32));
                    for v in &mut vertices {
                        v.pos[0] *= scale_x;
                        v.pos[1] *= scale_y;
                    }
                    let texture =
                        {
                            {
                                if self.assets.get_or_load_texture("crosshair",
                                                                   &mut self.factory).can_unwrap()
                                   {
                                    self.assets.get_or_load_texture("crosshair",
                                                                    &mut self.factory).unwrap()
                                } else {
                                    {
                                        {
                                            static _LOC: $crate::LogLocation =
                                                $crate::LogLocation{__line:
                                                                        117u32,
                                                                    __file:
                                                                        "hsgraphics/state.rs",
                                                                    __module_path:
                                                                        "horde_survival::hsgraphics::state",};
                                            let lvl = $crate::LogLevel::Error;
                                            if lvl <=
                                                   $crate::__static_max_level()
                                                   &&
                                                   lvl <=
                                                       $crate::max_log_level()
                                               {
                                                $crate::__log(lvl,
                                                              "horde_survival::hsgraphics::state",
                                                              &_LOC,
                                                              ::std::fmt::Arguments::new_v1({
                                                                                                static __STATIC_FMTSTR:
                                                                                                       &'static [&'static str]
                                                                                                       =
                                                                                                    &["Failed to get texture: crosshair"];
                                                                                                __STATIC_FMTSTR
                                                                                            },
                                                                                            &match ()
                                                                                                 {
                                                                                                 ()
                                                                                                 =>
                                                                                                 [],
                                                                                             }))
                                            }
                                        };
                                        {
                                            $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("hsgraphics/state.rs",
                                                                             117u32);
                                                                        &_FILE_LINE
                                                                    })
                                        };
                                    };
                                }
                            };
                        }.clone();
                    let object =
                        Object2d::from_slice(&mut self.factory, &vertices,
                                             texture);
                    self.add_object2d(object, CROSSHAIR_OBJECT_ID);
                }
            }
        }
        impl GraphicsState {
            pub fn add_object2d(&mut self, mut object: Object2d, id: usize) {
                object.id = id;
                self.objects2d.push(object);
            }
            pub fn remove_objects2d(&mut self, id: usize) {
                self.objects2d =
                    self.objects2d.iter().cloned().filter(|o|
                                                              o.id !=
                                                                  id).collect();
            }
            pub fn encode_objects2d(&mut self) {
                for object in &self.objects2d {
                    object.encode(&mut self.encoder, &self.pso2d,
                                  &mut self.data2d);
                }
            }
        }
        impl GraphicsState {
            pub fn add_object3d(&mut self, mut object: Object3d, id: usize) {
                object.id = id;
                self.objects3d.push(object);
            }
            pub fn remove_objects3d(&mut self, id: usize) {
                self.objects3d =
                    self.objects3d.iter().cloned().filter(|o|
                                                              o.id !=
                                                                  id).collect();
            }
            pub fn encode_objects3d(&mut self) {
                for object in &self.objects3d {
                    object.encode(&mut self.encoder, &self.pso3d,
                                  &mut self.data);
                }
            }
        }
        impl GraphicsState {
            pub fn reset_cursor(&mut self, window: &Window) {
                self.last_cursor_pos = self.window_center;
                let (x, y) = (self.window_center.0, self.window_center.1);
                if let Err(_) = window.set_cursor_position(x, y) {
                    {
                        static _LOC: $crate::LogLocation =
                            $crate::LogLocation{__line: 169u32,
                                                __file: "hsgraphics/state.rs",
                                                __module_path:
                                                    "horde_survival::hsgraphics::state",};
                        let lvl = $crate::LogLevel::Error;
                        if lvl <= $crate::__static_max_level() &&
                               lvl <= $crate::max_log_level() {
                            $crate::__log(lvl,
                                          "horde_survival::hsgraphics::state",
                                          &_LOC,
                                          ::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["Failed to set cursor position to (",
                                                                                  ", ",
                                                                                  ")"];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&x,
                                                                                &y)
                                                                             {
                                                                             (__arg0,
                                                                              __arg1)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt),
                                                                              ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         }))
                        }
                    };
                }
            }
        }
    }
    pub mod gfx3d {
        pub use gfx;
        pub use hsgraphics::ColorFormat;
        pub type DepthFormat = gfx::format::DepthStencil;
        #[rustc_copy_clone_marker]
        pub struct Vertex {
            pub pos: [f32; 4],
            pub tex_coord: [f32; 2],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Vertex {
            #[inline]
            fn clone(&self) -> Vertex {
                {
                    let _: ::std::clone::AssertParamIsClone<[f32; 4]>;
                    let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Vertex { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Vertex {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Vertex { pos: ref __self_0_0, tex_coord: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Vertex");
                        let _ = builder.field("pos", &&(*__self_0_0));
                        let _ = builder.field("tex_coord", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl $crate::pso::buffer::Structure<$crate::format::Format> for Vertex
         {
            fn query(name: &str)
             -> Option<$crate::pso::buffer::Element<$crate::format::Format>> {
                use std::mem::size_of;
                use $crate::pso::buffer::{Element, ElemOffset, ElemStride};
                let stride = size_of::<Vertex>() as ElemStride;
                let tmp: &Vertex = unsafe { ::std::mem::uninitialized() };
                let base = tmp as *const _ as usize;
                match name {
                    "a_Pos" =>
                    Some(Element{format:
                                     <[f32; 4] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.pos as *const _ as usize) - base)
                                         as ElemOffset,
                                 stride: stride,}),
                    "a_TexCoord" =>
                    Some(Element{format:
                                     <[f32; 2] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.tex_coord as *const _ as usize) -
                                          base) as ElemOffset,
                                 stride: stride,}),
                    _ => None,
                }
            }
        }
        #[rustc_copy_clone_marker]
        pub struct Locals {
            pub transform: [[f32; 4]; 4],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Locals {
            #[inline]
            fn clone(&self) -> Locals {
                {
                    let _: ::std::clone::AssertParamIsClone<[[f32; 4]; 4]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Locals { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Locals {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Locals { transform: ref __self_0_0 } => {
                        let mut builder = __arg_0.debug_struct("Locals");
                        let _ = builder.field("transform", &&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        impl $crate::pso::buffer::Structure<$crate::shade::ConstFormat> for
         Locals {
            fn query(name: &str)
             ->
                 Option<$crate::pso::buffer::Element<$crate::shade::ConstFormat>> {
                use std::mem::size_of;
                use $crate::pso::buffer::{Element, ElemOffset, ElemStride};
                let stride = size_of::<Locals>() as ElemStride;
                let tmp: &Locals = unsafe { ::std::mem::uninitialized() };
                let base = tmp as *const _ as usize;
                match name {
                    "u_Transform" =>
                    Some(Element{format:
                                     <[[f32; 4]; 4] as
                                         $crate::shade::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.transform as *const _ as usize) -
                                          base) as ElemOffset,
                                 stride: stride,}),
                    _ => None,
                }
            }
        }
        pub mod pipe {
            use $crate;
            #[allow(unused_imports)]
            use super::*;
            use $crate::pso::{DataLink, DataBind, Descriptor, InitError,
                              RawDataSet};
            pub struct Data<R: $crate::Resources> {
                pub vbuf: <gfx::VertexBuffer<Vertex> as DataBind<R>>::Data,
                pub transform: <gfx::Global<[[f32; 4]; 4]> as
                               DataBind<R>>::Data,
                pub locals: <gfx::ConstantBuffer<Locals> as
                            DataBind<R>>::Data,
                pub color: <gfx::TextureSampler<[f32; 4]> as
                           DataBind<R>>::Data,
                pub out_color: <gfx::RenderTarget<ColorFormat> as
                               DataBind<R>>::Data,
                pub out_depth: <gfx::DepthTarget<DepthFormat> as
                               DataBind<R>>::Data,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <R: ::std::clone::Clone + $crate::Resources>
             ::std::clone::Clone for Data<R> {
                #[inline]
                fn clone(&self) -> Data<R> {
                    match *self {
                        Data {
                        vbuf: ref __self_0_0,
                        transform: ref __self_0_1,
                        locals: ref __self_0_2,
                        color: ref __self_0_3,
                        out_color: ref __self_0_4,
                        out_depth: ref __self_0_5 } =>
                        Data{vbuf: ::std::clone::Clone::clone(&(*__self_0_0)),
                             transform:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             locals:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),
                             color:
                                 ::std::clone::Clone::clone(&(*__self_0_3)),
                             out_color:
                                 ::std::clone::Clone::clone(&(*__self_0_4)),
                             out_depth:
                                 ::std::clone::Clone::clone(&(*__self_0_5)),},
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <R: ::std::fmt::Debug + $crate::Resources> ::std::fmt::Debug
             for Data<R> {
                fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Data {
                        vbuf: ref __self_0_0,
                        transform: ref __self_0_1,
                        locals: ref __self_0_2,
                        color: ref __self_0_3,
                        out_color: ref __self_0_4,
                        out_depth: ref __self_0_5 } => {
                            let mut builder = __arg_0.debug_struct("Data");
                            let _ = builder.field("vbuf", &&(*__self_0_0));
                            let _ =
                                builder.field("transform", &&(*__self_0_1));
                            let _ = builder.field("locals", &&(*__self_0_2));
                            let _ = builder.field("color", &&(*__self_0_3));
                            let _ =
                                builder.field("out_color", &&(*__self_0_4));
                            let _ =
                                builder.field("out_depth", &&(*__self_0_5));
                            builder.finish()
                        }
                    }
                }
            }
            pub struct Meta {
                vbuf: gfx::VertexBuffer<Vertex>,
                transform: gfx::Global<[[f32; 4]; 4]>,
                locals: gfx::ConstantBuffer<Locals>,
                color: gfx::TextureSampler<[f32; 4]>,
                out_color: gfx::RenderTarget<ColorFormat>,
                out_depth: gfx::DepthTarget<DepthFormat>,
            }
            pub struct Init<'a> {
                pub vbuf: <gfx::VertexBuffer<Vertex> as DataLink<'a>>::Init,
                pub transform: <gfx::Global<[[f32; 4]; 4]> as
                               DataLink<'a>>::Init,
                pub locals: <gfx::ConstantBuffer<Locals> as
                            DataLink<'a>>::Init,
                pub color: <gfx::TextureSampler<[f32; 4]> as
                           DataLink<'a>>::Init,
                pub out_color: <gfx::RenderTarget<ColorFormat> as
                               DataLink<'a>>::Init,
                pub out_depth: <gfx::DepthTarget<DepthFormat> as
                               DataLink<'a>>::Init,
            }
            impl <'a> $crate::pso::PipelineInit for Init<'a> {
                type
                Meta
                =
                Meta;
                fn link_to(&self, desc: &mut Descriptor,
                           info: &$crate::ProgramInfo)
                 -> Result<Self::Meta, InitError> {
                    let mut meta =
                        Meta{vbuf:
                                 <gfx::VertexBuffer<Vertex> as
                                     DataLink<'a>>::new(),
                             transform:
                                 <gfx::Global<[[f32; 4]; 4]> as
                                     DataLink<'a>>::new(),
                             locals:
                                 <gfx::ConstantBuffer<Locals> as
                                     DataLink<'a>>::new(),
                             color:
                                 <gfx::TextureSampler<[f32; 4]> as
                                     DataLink<'a>>::new(),
                             out_color:
                                 <gfx::RenderTarget<ColorFormat> as
                                     DataLink<'a>>::new(),
                             out_depth:
                                 <gfx::DepthTarget<DepthFormat> as
                                     DataLink<'a>>::new(),};
                    for at in &info.vertex_attributes {
                        match meta.vbuf.link_input(at, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.transform.link_input(at, &self.transform) {
                            Some(Ok(d)) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.locals.link_input(at, &self.locals) {
                            Some(Ok(d)) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.color.link_input(at, &self.color) {
                            Some(Ok(d)) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.out_color.link_input(at, &self.out_color) {
                            Some(Ok(d)) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.out_depth.link_input(at, &self.out_depth) {
                            Some(Ok(d)) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        return Err(InitError::VertexImport(at.slot, None));
                    }
                    for cb in &info.constant_buffers {
                        match meta.vbuf.link_constant_buffer(cb, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.transform.link_constant_buffer(cb,
                                                                  &self.transform)
                            {
                            Some(Ok(())) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.locals.link_constant_buffer(cb,
                                                               &self.locals) {
                            Some(Ok(())) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.color.link_constant_buffer(cb, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out_color.link_constant_buffer(cb,
                                                                  &self.out_color)
                            {
                            Some(Ok(())) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out_depth.link_constant_buffer(cb,
                                                                  &self.out_depth)
                            {
                            Some(Ok(())) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        return Err(InitError::ConstantBuffer(cb.slot, None));
                    }
                    for gc in &info.globals {
                        match meta.vbuf.link_global_constant(gc, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.transform.link_global_constant(gc,
                                                                  &self.transform)
                            {
                            Some(Ok(())) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.locals.link_global_constant(gc,
                                                               &self.locals) {
                            Some(Ok(())) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.color.link_global_constant(gc, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out_color.link_global_constant(gc,
                                                                  &self.out_color)
                            {
                            Some(Ok(())) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out_depth.link_global_constant(gc,
                                                                  &self.out_depth)
                            {
                            Some(Ok(())) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        return Err(InitError::GlobalConstant(gc.location,
                                                             None));
                    }
                    for srv in &info.textures {
                        match meta.vbuf.link_resource_view(srv, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.transform.link_resource_view(srv,
                                                                &self.transform)
                            {
                            Some(Ok(())) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.locals.link_resource_view(srv,
                                                             &self.locals) {
                            Some(Ok(())) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.color.link_resource_view(srv, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.out_color.link_resource_view(srv,
                                                                &self.out_color)
                            {
                            Some(Ok(())) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.out_depth.link_resource_view(srv,
                                                                &self.out_depth)
                            {
                            Some(Ok(())) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        return Err(InitError::ResourceView(srv.slot, None));
                    }
                    for uav in &info.unordereds {
                        match meta.vbuf.link_unordered_view(uav, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.transform.link_unordered_view(uav,
                                                                 &self.transform)
                            {
                            Some(Ok(())) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.locals.link_unordered_view(uav,
                                                              &self.locals) {
                            Some(Ok(())) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.color.link_unordered_view(uav, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.out_color.link_unordered_view(uav,
                                                                 &self.out_color)
                            {
                            Some(Ok(())) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.out_depth.link_unordered_view(uav,
                                                                 &self.out_depth)
                            {
                            Some(Ok(())) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        return Err(InitError::UnorderedView(uav.slot, None));
                    }
                    for sm in &info.samplers {
                        match meta.vbuf.link_sampler(sm, &self.vbuf) {
                            Some(()) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.transform.link_sampler(sm, &self.transform)
                            {
                            Some(()) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.locals.link_sampler(sm, &self.locals) {
                            Some(()) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.color.link_sampler(sm, &self.color) {
                            Some(()) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.out_color.link_sampler(sm, &self.out_color)
                            {
                            Some(()) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.out_depth.link_sampler(sm, &self.out_depth)
                            {
                            Some(()) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        return Err(InitError::Sampler(sm.slot, None));
                    }
                    for out in &info.outputs {
                        match meta.vbuf.link_output(out, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.transform.link_output(out, &self.transform)
                            {
                            Some(Ok(d)) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.locals.link_output(out, &self.locals) {
                            Some(Ok(d)) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.color.link_output(out, &self.color) {
                            Some(Ok(d)) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out_color.link_output(out, &self.out_color)
                            {
                            Some(Ok(d)) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out_depth.link_output(out, &self.out_depth)
                            {
                            Some(Ok(d)) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        return Err(InitError::PixelExport(out.slot, None));
                    }
                    if !info.knows_outputs {
                        use $crate::shade::core as s;
                        let mut out =
                            s::OutputVar{name: String::new(),
                                         slot: 0,
                                         base_type: s::BaseType::F32,
                                         container:
                                             s::ContainerType::Vector(4),};
                        match meta.vbuf.link_output(&out, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.transform.link_output(&out,
                                                         &self.transform) {
                            Some(Ok(d)) => {
                                if !meta.transform.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.locals.link_output(&out, &self.locals) {
                            Some(Ok(d)) => {
                                if !meta.locals.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.color.link_output(&out, &self.color) {
                            Some(Ok(d)) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out_color.link_output(&out,
                                                         &self.out_color) {
                            Some(Ok(d)) => {
                                if !meta.out_color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out_depth.link_output(&out,
                                                         &self.out_depth) {
                            Some(Ok(d)) => {
                                if !meta.out_depth.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx3d.rs",
                                                                         7u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                    }
                    for _ in 0..1 {
                        if let Some(d) =
                               meta.vbuf.link_depth_stencil(&self.vbuf) {
                            if !meta.vbuf.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.vbuf.link_scissor() {
                            if !meta.vbuf.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.transform.link_depth_stencil(&self.transform)
                               {
                            if !meta.transform.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.transform.link_scissor() {
                            if !meta.transform.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.transform.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.locals.link_depth_stencil(&self.locals) {
                            if !meta.locals.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.locals.link_scissor() {
                            if !meta.locals.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.locals.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.color.link_depth_stencil(&self.color) {
                            if !meta.color.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.color.link_scissor() {
                            if !meta.color.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.out_color.link_depth_stencil(&self.out_color)
                               {
                            if !meta.out_color.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.out_color.link_scissor() {
                            if !meta.out_color.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out_color.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.out_depth.link_depth_stencil(&self.out_depth)
                               {
                            if !meta.out_depth.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.out_depth.link_scissor() {
                            if !meta.out_depth.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out_depth.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx3d.rs",
                                                                     7u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                    }
                    Ok(meta)
                }
            }
            impl <R: $crate::Resources> $crate::pso::PipelineData<R> for
             Data<R> {
                type
                Meta
                =
                Meta;
                fn bake_to(&self, out: &mut RawDataSet<R>, meta: &Self::Meta,
                           man: &mut $crate::handle::Manager<R>) {
                    meta.vbuf.bind_to(out, &self.vbuf, man);
                    meta.transform.bind_to(out, &self.transform, man);
                    meta.locals.bind_to(out, &self.locals, man);
                    meta.color.bind_to(out, &self.color, man);
                    meta.out_color.bind_to(out, &self.out_color, man);
                    meta.out_depth.bind_to(out, &self.out_depth, man);
                }
            }
            pub fn new() -> Init<'static> {
                Init{vbuf: (),
                     transform: "u_Transform",
                     locals: "Locals",
                     color: "t_Color",
                     out_color: "Target0",
                     out_depth: gfx::preset::depth::LESS_EQUAL_WRITE,}
            }
        }
        impl Vertex {
            pub fn new(pos: [f32; 3], tex_coord: [f32; 2]) -> Vertex {
                Vertex{pos: [pos[0], pos[1], pos[2], 1.0],
                       tex_coord: tex_coord,}
            }
        }
    }
    pub mod gfx2d {
        pub use gfx;
        pub use hsgraphics::ColorFormat;
        pub type Color = [f32; 3];
        pub const CLEAR_COLOR: [f32; 4] = [0.0, 0.35, 0.5, 1.0];
        #[rustc_copy_clone_marker]
        pub struct Vertex {
            pub pos: [f32; 2],
            pub uv: [f32; 2],
            pub color: [f32; 4],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Vertex {
            #[inline]
            fn clone(&self) -> Vertex {
                {
                    let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                    let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                    let _: ::std::clone::AssertParamIsClone<[f32; 4]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Vertex { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Vertex {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Vertex {
                    pos: ref __self_0_0,
                    uv: ref __self_0_1,
                    color: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Vertex");
                        let _ = builder.field("pos", &&(*__self_0_0));
                        let _ = builder.field("uv", &&(*__self_0_1));
                        let _ = builder.field("color", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl $crate::pso::buffer::Structure<$crate::format::Format> for Vertex
         {
            fn query(name: &str)
             -> Option<$crate::pso::buffer::Element<$crate::format::Format>> {
                use std::mem::size_of;
                use $crate::pso::buffer::{Element, ElemOffset, ElemStride};
                let stride = size_of::<Vertex>() as ElemStride;
                let tmp: &Vertex = unsafe { ::std::mem::uninitialized() };
                let base = tmp as *const _ as usize;
                match name {
                    "a_Pos" =>
                    Some(Element{format:
                                     <[f32; 2] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.pos as *const _ as usize) - base)
                                         as ElemOffset,
                                 stride: stride,}),
                    "a_Uv" =>
                    Some(Element{format:
                                     <[f32; 2] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.uv as *const _ as usize) - base)
                                         as ElemOffset,
                                 stride: stride,}),
                    "a_Color" =>
                    Some(Element{format:
                                     <[f32; 4] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.color as *const _ as usize) -
                                          base) as ElemOffset,
                                 stride: stride,}),
                    _ => None,
                }
            }
        }
        pub mod pipe {
            use $crate;
            #[allow(unused_imports)]
            use super::*;
            use $crate::pso::{DataLink, DataBind, Descriptor, InitError,
                              RawDataSet};
            pub struct Data<R: $crate::Resources> {
                pub vbuf: <gfx::VertexBuffer<Vertex> as DataBind<R>>::Data,
                pub color: <gfx::TextureSampler<[f32; 4]> as
                           DataBind<R>>::Data,
                pub out: <gfx::BlendTarget<ColorFormat> as DataBind<R>>::Data,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <R: ::std::clone::Clone + $crate::Resources>
             ::std::clone::Clone for Data<R> {
                #[inline]
                fn clone(&self) -> Data<R> {
                    match *self {
                        Data {
                        vbuf: ref __self_0_0,
                        color: ref __self_0_1,
                        out: ref __self_0_2 } =>
                        Data{vbuf: ::std::clone::Clone::clone(&(*__self_0_0)),
                             color:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             out:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),},
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <R: ::std::fmt::Debug + $crate::Resources> ::std::fmt::Debug
             for Data<R> {
                fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Data {
                        vbuf: ref __self_0_0,
                        color: ref __self_0_1,
                        out: ref __self_0_2 } => {
                            let mut builder = __arg_0.debug_struct("Data");
                            let _ = builder.field("vbuf", &&(*__self_0_0));
                            let _ = builder.field("color", &&(*__self_0_1));
                            let _ = builder.field("out", &&(*__self_0_2));
                            builder.finish()
                        }
                    }
                }
            }
            pub struct Meta {
                vbuf: gfx::VertexBuffer<Vertex>,
                color: gfx::TextureSampler<[f32; 4]>,
                out: gfx::BlendTarget<ColorFormat>,
            }
            pub struct Init<'a> {
                pub vbuf: <gfx::VertexBuffer<Vertex> as DataLink<'a>>::Init,
                pub color: <gfx::TextureSampler<[f32; 4]> as
                           DataLink<'a>>::Init,
                pub out: <gfx::BlendTarget<ColorFormat> as
                         DataLink<'a>>::Init,
            }
            impl <'a> $crate::pso::PipelineInit for Init<'a> {
                type
                Meta
                =
                Meta;
                fn link_to(&self, desc: &mut Descriptor,
                           info: &$crate::ProgramInfo)
                 -> Result<Self::Meta, InitError> {
                    let mut meta =
                        Meta{vbuf:
                                 <gfx::VertexBuffer<Vertex> as
                                     DataLink<'a>>::new(),
                             color:
                                 <gfx::TextureSampler<[f32; 4]> as
                                     DataLink<'a>>::new(),
                             out:
                                 <gfx::BlendTarget<ColorFormat> as
                                     DataLink<'a>>::new(),};
                    for at in &info.vertex_attributes {
                        match meta.vbuf.link_input(at, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.color.link_input(at, &self.color) {
                            Some(Ok(d)) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.out.link_input(at, &self.out) {
                            Some(Ok(d)) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        return Err(InitError::VertexImport(at.slot, None));
                    }
                    for cb in &info.constant_buffers {
                        match meta.vbuf.link_constant_buffer(cb, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.color.link_constant_buffer(cb, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out.link_constant_buffer(cb, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        return Err(InitError::ConstantBuffer(cb.slot, None));
                    }
                    for gc in &info.globals {
                        match meta.vbuf.link_global_constant(gc, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.color.link_global_constant(gc, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out.link_global_constant(gc, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        return Err(InitError::GlobalConstant(gc.location,
                                                             None));
                    }
                    for srv in &info.textures {
                        match meta.vbuf.link_resource_view(srv, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.color.link_resource_view(srv, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.out.link_resource_view(srv, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        return Err(InitError::ResourceView(srv.slot, None));
                    }
                    for uav in &info.unordereds {
                        match meta.vbuf.link_unordered_view(uav, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.color.link_unordered_view(uav, &self.color)
                            {
                            Some(Ok(())) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.out.link_unordered_view(uav, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        return Err(InitError::UnorderedView(uav.slot, None));
                    }
                    for sm in &info.samplers {
                        match meta.vbuf.link_sampler(sm, &self.vbuf) {
                            Some(()) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.color.link_sampler(sm, &self.color) {
                            Some(()) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.out.link_sampler(sm, &self.out) {
                            Some(()) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        return Err(InitError::Sampler(sm.slot, None));
                    }
                    for out in &info.outputs {
                        match meta.vbuf.link_output(out, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.color.link_output(out, &self.color) {
                            Some(Ok(d)) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out.link_output(out, &self.out) {
                            Some(Ok(d)) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        return Err(InitError::PixelExport(out.slot, None));
                    }
                    if !info.knows_outputs {
                        use $crate::shade::core as s;
                        let mut out =
                            s::OutputVar{name: String::new(),
                                         slot: 0,
                                         base_type: s::BaseType::F32,
                                         container:
                                             s::ContainerType::Vector(4),};
                        match meta.vbuf.link_output(&out, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.color.link_output(&out, &self.color) {
                            Some(Ok(d)) => {
                                if !meta.color.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out.link_output(&out, &self.out) {
                            Some(Ok(d)) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx2d.rs",
                                                                         8u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                    }
                    for _ in 0..1 {
                        if let Some(d) =
                               meta.vbuf.link_depth_stencil(&self.vbuf) {
                            if !meta.vbuf.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx2d.rs",
                                                                     8u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.vbuf.link_scissor() {
                            if !meta.vbuf.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx2d.rs",
                                                                     8u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.color.link_depth_stencil(&self.color) {
                            if !meta.color.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx2d.rs",
                                                                     8u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.color.link_scissor() {
                            if !meta.color.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.color.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx2d.rs",
                                                                     8u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.out.link_depth_stencil(&self.out) {
                            if !meta.out.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx2d.rs",
                                                                     8u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.out.link_scissor() {
                            if !meta.out.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx2d.rs",
                                                                     8u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                    }
                    Ok(meta)
                }
            }
            impl <R: $crate::Resources> $crate::pso::PipelineData<R> for
             Data<R> {
                type
                Meta
                =
                Meta;
                fn bake_to(&self, out: &mut RawDataSet<R>, meta: &Self::Meta,
                           man: &mut $crate::handle::Manager<R>) {
                    meta.vbuf.bind_to(out, &self.vbuf, man);
                    meta.color.bind_to(out, &self.color, man);
                    meta.out.bind_to(out, &self.out, man);
                }
            }
            pub fn new() -> Init<'static> {
                Init{vbuf: (),
                     color: "t_Color",
                     out:
                         ("f_Output", gfx::state::MASK_ALL,
                          gfx::preset::blend::ALPHA),}
            }
        }
        impl Vertex {
            pub fn new(pos: [f32; 2], uv: [f32; 2]) -> Vertex {
                Vertex{pos: pos, uv: uv, color: [1.0; 4],}
            }
            pub fn new_colored(pos: [f32; 2], uv: [f32; 2], color: [f32; 4])
             -> Vertex {
                Vertex{pos: pos, uv: uv, color: color,}
            }
        }
    }
    pub mod gfx_gui {
        pub use gfx::{self, Slice};
        use gfx::traits::FactoryExt;
        use gfx_device_gl::{Factory, Resources};
        pub use hsgraphics::ColorFormat;
        use hsgraphics::object::ObjectEncoder;
        pub type Pso = gfx::PipelineState<Resources, pipe::Meta>;
        pub type VBufferGUI = gfx::handle::Buffer<Resources, Vertex>;
        #[rustc_copy_clone_marker]
        pub struct Vertex {
            pub pos: [f32; 2],
            pub color: [f32; 4],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Vertex {
            #[inline]
            fn clone(&self) -> Vertex {
                {
                    let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                    let _: ::std::clone::AssertParamIsClone<[f32; 4]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Vertex { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Vertex {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Vertex { pos: ref __self_0_0, color: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("Vertex");
                        let _ = builder.field("pos", &&(*__self_0_0));
                        let _ = builder.field("color", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl $crate::pso::buffer::Structure<$crate::format::Format> for Vertex
         {
            fn query(name: &str)
             -> Option<$crate::pso::buffer::Element<$crate::format::Format>> {
                use std::mem::size_of;
                use $crate::pso::buffer::{Element, ElemOffset, ElemStride};
                let stride = size_of::<Vertex>() as ElemStride;
                let tmp: &Vertex = unsafe { ::std::mem::uninitialized() };
                let base = tmp as *const _ as usize;
                match name {
                    "a_Pos" =>
                    Some(Element{format:
                                     <[f32; 2] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.pos as *const _ as usize) - base)
                                         as ElemOffset,
                                 stride: stride,}),
                    "a_Color" =>
                    Some(Element{format:
                                     <[f32; 4] as
                                         $crate::format::Formatted>::get_format(),
                                 offset:
                                     ((&tmp.color as *const _ as usize) -
                                          base) as ElemOffset,
                                 stride: stride,}),
                    _ => None,
                }
            }
        }
        pub mod pipe {
            use $crate;
            #[allow(unused_imports)]
            use super::*;
            use $crate::pso::{DataLink, DataBind, Descriptor, InitError,
                              RawDataSet};
            pub struct Data<R: $crate::Resources> {
                pub vbuf: <gfx::VertexBuffer<Vertex> as DataBind<R>>::Data,
                pub out: <gfx::BlendTarget<ColorFormat> as DataBind<R>>::Data,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <R: ::std::clone::Clone + $crate::Resources>
             ::std::clone::Clone for Data<R> {
                #[inline]
                fn clone(&self) -> Data<R> {
                    match *self {
                        Data { vbuf: ref __self_0_0, out: ref __self_0_1 } =>
                        Data{vbuf: ::std::clone::Clone::clone(&(*__self_0_0)),
                             out:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <R: ::std::fmt::Debug + $crate::Resources> ::std::fmt::Debug
             for Data<R> {
                fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Data { vbuf: ref __self_0_0, out: ref __self_0_1 } =>
                        {
                            let mut builder = __arg_0.debug_struct("Data");
                            let _ = builder.field("vbuf", &&(*__self_0_0));
                            let _ = builder.field("out", &&(*__self_0_1));
                            builder.finish()
                        }
                    }
                }
            }
            pub struct Meta {
                vbuf: gfx::VertexBuffer<Vertex>,
                out: gfx::BlendTarget<ColorFormat>,
            }
            pub struct Init<'a> {
                pub vbuf: <gfx::VertexBuffer<Vertex> as DataLink<'a>>::Init,
                pub out: <gfx::BlendTarget<ColorFormat> as
                         DataLink<'a>>::Init,
            }
            impl <'a> $crate::pso::PipelineInit for Init<'a> {
                type
                Meta
                =
                Meta;
                fn link_to(&self, desc: &mut Descriptor,
                           info: &$crate::ProgramInfo)
                 -> Result<Self::Meta, InitError> {
                    let mut meta =
                        Meta{vbuf:
                                 <gfx::VertexBuffer<Vertex> as
                                     DataLink<'a>>::new(),
                             out:
                                 <gfx::BlendTarget<ColorFormat> as
                                     DataLink<'a>>::new(),};
                    for at in &info.vertex_attributes {
                        match meta.vbuf.link_input(at, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        match meta.out.link_input(at, &self.out) {
                            Some(Ok(d)) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.attributes[at.slot as usize] = Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::VertexImport(at.slot,
                                                               Some(fm))),
                            None => (),
                        }
                        return Err(InitError::VertexImport(at.slot, None));
                    }
                    for cb in &info.constant_buffers {
                        match meta.vbuf.link_constant_buffer(cb, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out.link_constant_buffer(cb, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ConstantBuffer(cb.slot,
                                                                 Some(()))),
                            None => (),
                        }
                        return Err(InitError::ConstantBuffer(cb.slot, None));
                    }
                    for gc in &info.globals {
                        match meta.vbuf.link_global_constant(gc, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        match meta.out.link_global_constant(gc, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::GlobalConstant(gc.location,
                                                                 Some(()))),
                            None => (),
                        }
                        return Err(InitError::GlobalConstant(gc.location,
                                                             None));
                    }
                    for srv in &info.textures {
                        match meta.vbuf.link_resource_view(srv, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        match meta.out.link_resource_view(srv, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::ResourceView(srv.slot,
                                                               Some(()))),
                            None => (),
                        }
                        return Err(InitError::ResourceView(srv.slot, None));
                    }
                    for uav in &info.unordereds {
                        match meta.vbuf.link_unordered_view(uav, &self.vbuf) {
                            Some(Ok(())) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        match meta.out.link_unordered_view(uav, &self.out) {
                            Some(Ok(())) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            Some(Err(_)) =>
                            return Err(InitError::UnorderedView(uav.slot,
                                                                Some(()))),
                            None => (),
                        }
                        return Err(InitError::UnorderedView(uav.slot, None));
                    }
                    for sm in &info.samplers {
                        match meta.vbuf.link_sampler(sm, &self.vbuf) {
                            Some(()) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        match meta.out.link_sampler(sm, &self.out) {
                            Some(()) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                continue ;
                            }
                            None => (),
                        }
                        return Err(InitError::Sampler(sm.slot, None));
                    }
                    for out in &info.outputs {
                        match meta.vbuf.link_output(out, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out.link_output(out, &self.out) {
                            Some(Ok(d)) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                continue ;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        return Err(InitError::PixelExport(out.slot, None));
                    }
                    if !info.knows_outputs {
                        use $crate::shade::core as s;
                        let mut out =
                            s::OutputVar{name: String::new(),
                                         slot: 0,
                                         base_type: s::BaseType::F32,
                                         container:
                                             s::ContainerType::Vector(4),};
                        match meta.vbuf.link_output(&out, &self.vbuf) {
                            Some(Ok(d)) => {
                                if !meta.vbuf.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                        match meta.out.link_output(&out, &self.out) {
                            Some(Ok(d)) => {
                                if !meta.out.is_active() {
                                    {
                                        $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/gfx_gui.rs",
                                                                         11u32);
                                                                    &_FILE_LINE
                                                                })
                                    }
                                };
                                desc.color_targets[out.slot as usize] =
                                    Some(d);
                                out.slot += 1;
                            }
                            Some(Err(fm)) =>
                            return Err(InitError::PixelExport(out.slot,
                                                              Some(fm))),
                            None => (),
                        }
                    }
                    for _ in 0..1 {
                        if let Some(d) =
                               meta.vbuf.link_depth_stencil(&self.vbuf) {
                            if !meta.vbuf.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx_gui.rs",
                                                                     11u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.vbuf.link_scissor() {
                            if !meta.vbuf.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.vbuf.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx_gui.rs",
                                                                     11u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                        if let Some(d) =
                               meta.out.link_depth_stencil(&self.out) {
                            if !meta.out.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx_gui.rs",
                                                                     11u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.depth_stencil = Some(d);
                        }
                        if meta.out.link_scissor() {
                            if !meta.out.is_active() {
                                {
                                    $crate::rt::begin_panic("assertion failed: meta.out.is_active()",
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/gfx_gui.rs",
                                                                     11u32);
                                                                &_FILE_LINE
                                                            })
                                }
                            };
                            desc.scissor = true;
                        }
                    }
                    Ok(meta)
                }
            }
            impl <R: $crate::Resources> $crate::pso::PipelineData<R> for
             Data<R> {
                type
                Meta
                =
                Meta;
                fn bake_to(&self, out: &mut RawDataSet<R>, meta: &Self::Meta,
                           man: &mut $crate::handle::Manager<R>) {
                    meta.vbuf.bind_to(out, &self.vbuf, man);
                    meta.out.bind_to(out, &self.out, man);
                }
            }
            pub fn new() -> Init<'static> {
                Init{vbuf: (),
                     out:
                         ("Target0", gfx::state::MASK_ALL,
                          gfx::preset::blend::ALPHA),}
            }
        }
        impl Vertex {
            pub fn new(pos: [f32; 2], color: [f32; 4]) -> Vertex {
                Vertex{pos: pos, color: color,}
            }
        }
        pub struct GUIObject {
            pub vbuf: VBufferGUI,
            pub slice: Slice<Resources>,
        }
        impl GUIObject {
            pub fn new(factory: &mut Factory, vertices: &[Vertex],
                       indices: &[u16]) -> GUIObject {
                let (vbuf, slice) =
                    factory.create_vertex_buffer_with_slice(vertices,
                                                            indices);
                GUIObject{vbuf: vbuf, slice: slice,}
            }
            pub fn encode(&self, encoder: &mut ObjectEncoder, pso: &Pso,
                          data: &mut pipe::Data<Resources>) {
                data.vbuf = self.vbuf.clone();
                encoder.draw(&self.slice, pso, data);
            }
        }
    }
    pub mod object {
        pub mod object2d {
            use gfx::Slice;
            use gfx::traits::FactoryExt;
            use gfx_device_gl::{Factory, Resources};
            use hsgraphics::texture::Texture;
            use hsgraphics::gfx2d::*;
            use hsgraphics::object::*;
            pub type ObjectPSO = gfx::PipelineState<Resources, pipe::Meta>;
            pub type VBuffer2d = gfx::handle::Buffer<Resources, Vertex>;
            pub struct Object2d {
                pub vbuf: VBuffer2d,
                pub slice: Slice<Resources>,
                pub id: usize,
                pub texture: Texture,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Object2d {
                #[inline]
                fn clone(&self) -> Object2d {
                    match *self {
                        Object2d {
                        vbuf: ref __self_0_0,
                        slice: ref __self_0_1,
                        id: ref __self_0_2,
                        texture: ref __self_0_3 } =>
                        Object2d{vbuf:
                                     ::std::clone::Clone::clone(&(*__self_0_0)),
                                 slice:
                                     ::std::clone::Clone::clone(&(*__self_0_1)),
                                 id:
                                     ::std::clone::Clone::clone(&(*__self_0_2)),
                                 texture:
                                     ::std::clone::Clone::clone(&(*__self_0_3)),},
                    }
                }
            }
            impl Object2d {
                pub fn new(vbuf: VBuffer2d, slice: Slice<Resources>,
                           texture: Texture) -> Object2d {
                    Object2d{vbuf: vbuf,
                             slice: slice,
                             id: 0,
                             texture: texture,}
                }
                pub fn from_slice(factory: &mut Factory, slice: &[Vertex],
                                  texture: Texture) -> Object2d {
                    let (vertex_buffer, slice) =
                        factory.create_vertex_buffer_with_slice(slice, ());
                    Object2d::new(vertex_buffer, slice, texture)
                }
                pub fn from_slice_indices(factory: &mut Factory,
                                          slice: &[Vertex], indices: &[u16],
                                          texture: Texture) -> Object2d {
                    let (vertex_buffer, slice) =
                        factory.create_vertex_buffer_with_slice(slice,
                                                                indices);
                    Object2d::new(vertex_buffer, slice, texture)
                }
            }
            impl Object2d {
                pub fn encode(&self, encoder: &mut ObjectEncoder,
                              pso: &ObjectPSO,
                              data: &mut pipe::Data<Resources>) {
                    data.vbuf = self.vbuf.clone();
                    data.color.0 = self.texture.clone();
                    encoder.draw(&self.slice, pso, data);
                }
            }
        }
        pub mod object3d {
            use gfx;
            use gfx::traits::FactoryExt;
            use gfx_device_gl::{Resources, Factory};
            use hsgraphics::*;
            pub type Object3dColor =
                gfx::handle::RenderTargetView<Resources, ColorFormat>;
            pub type Object3dDepth =
                gfx::handle::DepthStencilView<Resources, ObjectDepth>;
            pub type ObjectPSO =
                gfx::PipelineState<Resources, gfx3d::pipe::Meta>;
            pub type VBuffer = gfx::handle::Buffer<Resources, gfx3d::Vertex>;
            pub struct Object3d {
                pub id: usize,
                slice: gfx::Slice<Resources>,
                buf: VBuffer,
                texture: Texture,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Object3d {
                #[inline]
                fn clone(&self) -> Object3d {
                    match *self {
                        Object3d {
                        id: ref __self_0_0,
                        slice: ref __self_0_1,
                        buf: ref __self_0_2,
                        texture: ref __self_0_3 } =>
                        Object3d{id:
                                     ::std::clone::Clone::clone(&(*__self_0_0)),
                                 slice:
                                     ::std::clone::Clone::clone(&(*__self_0_1)),
                                 buf:
                                     ::std::clone::Clone::clone(&(*__self_0_2)),
                                 texture:
                                     ::std::clone::Clone::clone(&(*__self_0_3)),},
                    }
                }
            }
            impl Object3d {
                pub fn new(slice: gfx::Slice<Resources>, buf: VBuffer,
                           texture: Texture) -> Object3d {
                    Object3d{id: 0, slice: slice, buf: buf, texture: texture,}
                }
                pub fn from_slice(factory: &mut Factory,
                                  slice: &[gfx3d::Vertex], index_data: &[u16],
                                  texture: Texture) -> Object3d {
                    let (vbuf, slice) =
                        factory.create_vertex_buffer_with_slice(slice,
                                                                index_data);
                    Object3d::new(slice, vbuf, texture)
                }
            }
            impl Object3d {
                pub fn encode(&self, encoder: &mut ObjectEncoder,
                              pso: &ObjectPSO,
                              data: &mut gfx3d::pipe::Data<Resources>) {
                    data.color.0 = self.texture.clone();
                    data.vbuf = self.buf.clone();
                    encoder.draw(&self.slice, pso, data);
                }
            }
        }
        use {gfx, gfx_device_gl};
        use hsgraphics::ColorFormat;
        pub type ObjectEncoder =
            gfx::Encoder<gfx_device_gl::Resources,
                         gfx_device_gl::CommandBuffer>;
        pub type ObjectColor =
            gfx::handle::RenderTargetView<gfx_device_gl::Resources,
                                          ColorFormat>;
        pub type ObjectDepth = (gfx::format::D24_S8, gfx::format::Unorm);
    }
    pub mod texture {
        use gfx::*;
        use gfx::handle::ShaderResourceView;
        use gfx_device_gl;
        pub type Texture =
            ShaderResourceView<gfx_device_gl::Resources, [f32; 4]>;
        pub use image_utils::{load_texture, load_texture_raw};
        use hsgraphics::{ColorFormat, SurfaceFormat, FullFormat,
                         ObjectEncoder};
        pub fn update_cache_texture(encoder: &mut ObjectEncoder,
                                    texture:
                                        &handle::Texture<gfx_device_gl::Resources,
                                                         SurfaceFormat>,
                                    offset: [u16; 2], size: [u16; 2],
                                    data: &[[u8; 4]]) {
            let info =
                tex::ImageInfoCommon{xoffset: offset[0],
                                     yoffset: offset[1],
                                     zoffset: 0,
                                     width: size[0],
                                     height: size[1],
                                     depth: 0,
                                     format: (),
                                     mipmap: 0,};
            encoder.update_texture::<SurfaceFormat,
                                     FullFormat>(texture, None, info,
                                                 data).expect("Failed to update texture");
        }
        pub fn create_cache_texture<F,
                                    R>(factory: &mut F, width: u32,
                                       height: u32)
         ->
             (handle::Texture<R, SurfaceFormat>,
              ShaderResourceView<R, [f32; 4]>) where F: Factory<R>,
         R: Resources {
            let data =
                $crate::vec::from_elem(0, (width * height * 4) as usize);
            let kind =
                tex::Kind::D2(width as tex::Size, height as tex::Size,
                              tex::AaMode::Single);
            match factory.create_texture_const_u8::<ColorFormat>(kind,
                                                                 &[&data]) {
                Ok(t) => t,
                Err(e) => {
                    {
                        static _LOC: $crate::LogLocation =
                            $crate::LogLocation{__line: 40u32,
                                                __file:
                                                    "hsgraphics/texture.rs",
                                                __module_path:
                                                    "horde_survival::hsgraphics::texture",};
                        let lvl = $crate::LogLevel::Error;
                        if lvl <= $crate::__static_max_level() &&
                               lvl <= $crate::max_log_level() {
                            $crate::__log(lvl,
                                          "horde_survival::hsgraphics::texture",
                                          &_LOC,
                                          ::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &["Failed to create texture: "];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&e,)
                                                                             {
                                                                             (__arg0,)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         }))
                        }
                    };
                    {
                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("hsgraphics/texture.rs",
                                                         40u32);
                                                    &_FILE_LINE
                                                })
                    };
                }
            }
        }
    }
    pub mod camera {
        use cgmath::{self, Point3, Vector3, Matrix4, Transform};
        use world::Coords;
        use consts::{VERTICAL_FOV, WORLD_SCALE};
        pub fn get_camera(mut coords: Coords, direction: (f64, f64),
                          aspect_ratio: f32) -> Matrix4<f32> {
            coords.scale(WORLD_SCALE as f64);
            let mut pointing_to = coords.clone();
            pointing_to.move_3d(direction, 1.0);
            let camera_pos =
                Point3::new(coords.x as f32, coords.z as f32,
                            coords.y as f32);
            let pointing_to =
                Point3::new(pointing_to.x as f32, pointing_to.z as f32,
                            pointing_to.y as f32);
            let view: Matrix4<f32> =
                Transform::look_at(camera_pos, pointing_to,
                                   Vector3::unit_z());
            let proj =
                cgmath::perspective(cgmath::Deg(VERTICAL_FOV), aspect_ratio,
                                    0.01, 100.0);
            proj * view
        }
    }
    pub mod options {
        use consts::defaults::*;
        pub struct GraphicsOptions {
            pub window_size: (u32, u32),
            pub minimap_enabled: bool,
            pub display_debug: bool,
            pub crosshair: bool,
            pub fullscreen: bool,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for GraphicsOptions {
            #[inline]
            fn clone(&self) -> GraphicsOptions {
                match *self {
                    GraphicsOptions {
                    window_size: ref __self_0_0,
                    minimap_enabled: ref __self_0_1,
                    display_debug: ref __self_0_2,
                    crosshair: ref __self_0_3,
                    fullscreen: ref __self_0_4 } =>
                    GraphicsOptions{window_size:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    minimap_enabled:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    display_debug:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    crosshair:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),
                                    fullscreen:
                                        ::std::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        impl GraphicsOptions {
            pub fn new() -> GraphicsOptions {
                GraphicsOptions{window_size: (WINDOW_WIDTH, WINDOW_HEIGHT),
                                minimap_enabled: false,
                                display_debug: false,
                                crosshair: false,
                                fullscreen: false,}
            }
        }
        impl GraphicsOptions {
            pub fn window_size(&mut self, width: u32, height: u32)
             -> &mut Self {
                self.window_size = (width, height);
                self
            }
            pub fn minimap_enabled(&mut self, value: bool) -> &mut Self {
                self.minimap_enabled = value;
                self
            }
            pub fn display_debug(&mut self, value: bool) -> &mut Self {
                self.display_debug = value;
                self
            }
            pub fn crosshair(&mut self, value: bool) -> &mut Self {
                self.crosshair = value;
                self
            }
            pub fn fullscreen(&mut self, value: bool) -> &mut Self {
                self.fullscreen = value;
                self
            }
        }
    }
    pub mod cache {
        use conrod::text::GlyphCache;
        use gfx::handle;
        use gfx_device_gl;
        use hsgraphics::{Texture, SurfaceFormat};
        pub struct TextCache {
            pub cache: GlyphCache,
            pub texture: handle::Texture<gfx_device_gl::Resources,
                                         SurfaceFormat>,
            pub texture_view: Texture,
        }
        impl TextCache {
            pub fn new(cache: GlyphCache,
                       texture:
                           handle::Texture<gfx_device_gl::Resources,
                                           SurfaceFormat>,
                       texture_view: Texture) -> TextCache {
                TextCache{cache: cache,
                          texture: texture,
                          texture_view: texture_view,}
            }
        }
    }
    mod shaders {
        use gfx::pso::PipelineInit;
        use gfx::traits::FactoryExt;
        use gfx::state::Rasterizer;
        use gfx::{PipelineState, Primitive, PipelineStateError};
        use gfx_device_gl::{Factory, Resources, Device};
        use shader_version::glsl::GLSL;
        use shader_version::{Shaders, PickShader};
        use assets::load::load_bytes;
        use std::path::Path;
        pub fn load_pso<P,
                        I>(factory: &mut Factory, vs_path: P, fs_path: P,
                           primitive: Primitive, pipe: I)
         -> Result<PipelineState<Resources, I::Meta>, PipelineStateError>
         where I: PipelineInit, P: AsRef<Path> + Clone {
            let vs =
                match load_bytes(vs_path.clone()) {
                    Ok(b) => b,
                    Err(e) => {
                        {
                            static _LOC: $crate::LogLocation =
                                $crate::LogLocation{__line: 23u32,
                                                    __file:
                                                        "hsgraphics/shaders.rs",
                                                    __module_path:
                                                        "horde_survival::hsgraphics::shaders",};
                            let lvl = $crate::LogLevel::Error;
                            if lvl <= $crate::__static_max_level() &&
                                   lvl <= $crate::max_log_level() {
                                $crate::__log(lvl,
                                              "horde_survival::hsgraphics::shaders",
                                              &_LOC,
                                              ::std::fmt::Arguments::new_v1({
                                                                                static __STATIC_FMTSTR:
                                                                                       &'static [&'static str]
                                                                                       =
                                                                                    &[""];
                                                                                __STATIC_FMTSTR
                                                                            },
                                                                            &match (&$crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                                                                           static __STATIC_FMTSTR:
                                                                                                                                                  &'static [&'static str]
                                                                                                                                                  =
                                                                                                                                               &["Failed to load vertex shader source (",
                                                                                                                                                 "): "];
                                                                                                                                           __STATIC_FMTSTR
                                                                                                                                       },
                                                                                                                                       &match (&e,
                                                                                                                                               &vs_path.as_ref().to_str().unwrap())
                                                                                                                                            {
                                                                                                                                            (__arg0,
                                                                                                                                             __arg1)
                                                                                                                                            =>
                                                                                                                                            [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                                                         ::std::fmt::Display::fmt),
                                                                                                                                             ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                                                         ::std::fmt::Display::fmt)],
                                                                                                                                        })),)
                                                                                 {
                                                                                 (__arg0,)
                                                                                 =>
                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                              ::std::fmt::Display::fmt)],
                                                                             }))
                            }
                        };
                        {
                            $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("hsgraphics/shaders.rs",
                                                             23u32);
                                                        &_FILE_LINE
                                                    })
                        };
                    }
                };
            let fs =
                match load_bytes(fs_path.clone()) {
                    Ok(b) => b,
                    Err(e) => {
                        {
                            static _LOC: $crate::LogLocation =
                                $crate::LogLocation{__line: 28u32,
                                                    __file:
                                                        "hsgraphics/shaders.rs",
                                                    __module_path:
                                                        "horde_survival::hsgraphics::shaders",};
                            let lvl = $crate::LogLevel::Error;
                            if lvl <= $crate::__static_max_level() &&
                                   lvl <= $crate::max_log_level() {
                                $crate::__log(lvl,
                                              "horde_survival::hsgraphics::shaders",
                                              &_LOC,
                                              ::std::fmt::Arguments::new_v1({
                                                                                static __STATIC_FMTSTR:
                                                                                       &'static [&'static str]
                                                                                       =
                                                                                    &[""];
                                                                                __STATIC_FMTSTR
                                                                            },
                                                                            &match (&$crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                                                                           static __STATIC_FMTSTR:
                                                                                                                                                  &'static [&'static str]
                                                                                                                                                  =
                                                                                                                                               &["Failed to load fragment shader source (",
                                                                                                                                                 "): "];
                                                                                                                                           __STATIC_FMTSTR
                                                                                                                                       },
                                                                                                                                       &match (&e,
                                                                                                                                               &fs_path.as_ref().to_str().unwrap())
                                                                                                                                            {
                                                                                                                                            (__arg0,
                                                                                                                                             __arg1)
                                                                                                                                            =>
                                                                                                                                            [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                                                         ::std::fmt::Display::fmt),
                                                                                                                                             ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                                                         ::std::fmt::Display::fmt)],
                                                                                                                                        })),)
                                                                                 {
                                                                                 (__arg0,)
                                                                                 =>
                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                              ::std::fmt::Display::fmt)],
                                                                             }))
                            }
                        };
                        {
                            $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("hsgraphics/shaders.rs",
                                                             28u32);
                                                        &_FILE_LINE
                                                    })
                        };
                    }
                };
            let set =
                match factory.create_shader_set(&vs, &fs) {
                    $crate::result::Result::Ok(val) => val,
                    $crate::result::Result::Err(err) => {
                        return $crate::result::Result::Err($crate::convert::From::from(err))
                    }
                };
            factory.create_pipeline_state(&set, primitive,
                                          Rasterizer::new_fill(), pipe)
        }
        pub fn get_shader_version_path(device: &Device, suffix: &str)
         -> String {
            let dev_glsl_version = device.get_info().shading_language;
            let glsl_version =
                match (dev_glsl_version.major, dev_glsl_version.minor) {
                    (1, 10) => GLSL::V1_10,
                    (1, 20) => GLSL::V1_20,
                    (1, 30) => GLSL::V1_30,
                    (1, 40) => GLSL::V1_40,
                    (1, 50) => GLSL::V1_50,
                    (3, 30) => GLSL::V3_30,
                    (4, 0) => GLSL::V4_00,
                    (4, 10) => GLSL::V4_10,
                    (4, 20) => GLSL::V4_20,
                    (4, 30) => GLSL::V4_30,
                    (4, 40) => GLSL::V4_40,
                    (4, 50) => GLSL::V4_50,
                    v => {
                        $crate::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1({
                                                                                       static __STATIC_FMTSTR:
                                                                                              &'static [&'static str]
                                                                                              =
                                                                                           &["Unknown GLSL version: "];
                                                                                       __STATIC_FMTSTR
                                                                                   },
                                                                                   &match (&v,)
                                                                                        {
                                                                                        (__arg0,)
                                                                                        =>
                                                                                        [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                     ::std::fmt::Debug::fmt)],
                                                                                    }),
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("hsgraphics/shaders.rs",
                                                             51u32);
                                                        &_FILE_LINE
                                                    })
                    }
                };
            let mut shaders = Shaders::new();
            shaders.set(GLSL::V1_10, "110").set(GLSL::V1_50, "150");
            let version =
                glsl_version.pick_shader(&shaders).expect(&$crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                                                 static __STATIC_FMTSTR:
                                                                                                                        &'static [&'static str]
                                                                                                                        =
                                                                                                                     &["Failed to pick shader (GLSL "];
                                                                                                                 __STATIC_FMTSTR
                                                                                                             },
                                                                                                             &match (&dev_glsl_version,)
                                                                                                                  {
                                                                                                                  (__arg0,)
                                                                                                                  =>
                                                                                                                  [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                               ::std::fmt::Debug::fmt)],
                                                                                                              })));
            $crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                  static __STATIC_FMTSTR:
                                                                         &'static [&'static str]
                                                                         =
                                                                      &["",
                                                                        "/"];
                                                                  __STATIC_FMTSTR
                                                              },
                                                              &match (&version,
                                                                      &suffix)
                                                                   {
                                                                   (__arg0,
                                                                    __arg1) =>
                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                ::std::fmt::Display::fmt),
                                                                    ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                ::std::fmt::Display::fmt)],
                                                               }))
        }
    }
    mod entity {
        use consts::*;
        use hsgraphics::*;
        use hsgraphics::object3d::Object3d;
        use hsgraphics::utils::*;
        use hslog::CanUnwrap;
        use entity::Entity;
        impl GraphicsState {
            pub fn update_entity_objects(&mut self, entities: &[Entity],
                                         player_entity_id: usize) {
                self.remove_objects3d(ENTITY_OBJECT_ID);
                for entity in entities {
                    if entity.id == player_entity_id { continue ; }
                    let name = get_texture_name(&entity.entity_type);
                    let texture =
                        {
                            if self.assets.get_or_load_texture(name,
                                                               &mut self.factory).can_unwrap()
                               {
                                self.assets.get_or_load_texture(name,
                                                                &mut self.factory).unwrap()
                            } else {
                                {
                                    {
                                        static _LOC: $crate::LogLocation =
                                            $crate::LogLocation{__line: 22u32,
                                                                __file:
                                                                    "hsgraphics/entity.rs",
                                                                __module_path:
                                                                    "horde_survival::hsgraphics::entity",};
                                        let lvl = $crate::LogLevel::Error;
                                        if lvl <= $crate::__static_max_level()
                                               &&
                                               lvl <= $crate::max_log_level()
                                           {
                                            $crate::__log(lvl,
                                                          "horde_survival::hsgraphics::entity",
                                                          &_LOC,
                                                          ::std::fmt::Arguments::new_v1({
                                                                                            static __STATIC_FMTSTR:
                                                                                                   &'static [&'static str]
                                                                                                   =
                                                                                                &["Failed to load texture for "];
                                                                                            __STATIC_FMTSTR
                                                                                        },
                                                                                        &match (&entity.entity_type,)
                                                                                             {
                                                                                             (__arg0,)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                          ::std::fmt::Debug::fmt)],
                                                                                         }))
                                        }
                                    };
                                    {
                                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("hsgraphics/entity.rs",
                                                                         22u32);
                                                                    &_FILE_LINE
                                                                })
                                    };
                                };
                            }
                        };
                    let size = get_entity_box_size(&entity.entity_type);
                    let coords = get_unscaled_cube_coords(&entity.coords);
                    let (v, i) = shapes3d::cube(coords, size);
                    let mut cube_object =
                        Object3d::from_slice(&mut self.factory, &v, &i,
                                             texture.clone());
                    cube_object.id = ENTITY_OBJECT_ID;
                    self.objects3d.push(cube_object);
                }
            }
        }
    }
    mod utils {
        use entity::EntityType;
        use world::Coords;
        pub fn get_texture_name(entity_type: &EntityType) -> &str {
            match *entity_type {
                EntityType::Player => "player",
                EntityType::Zombie => "zombie",
                EntityType::FlyingBallLinear => "ball_linear",
                EntityType::FlyingBallArc => "ball_arc",
            }
        }
        pub fn get_unscaled_cube_coords(coords: &Coords) -> [f32; 3] {
            [coords.x as f32, coords.z as f32, coords.y as f32]
        }
    }
    mod init {
        use glutin::{self, Window, GlRequest};
        use gfx::{self, Factory, Primitive, tex};
        use gfx::traits::FactoryExt;
        use conrod::text::GlyphCache;
        use gfx_window_glutin;
        use consts::*;
        use hsgraphics::*;
        use hsgraphics::shaders::*;
        use assets::AssetLoader;
        use gamestate::GameState;
        impl GraphicsState {
            pub fn new(options: GraphicsOptions, game: &GameState)
             -> (GraphicsState, Window) {
                let gl =
                    GlRequest::GlThenGles{opengles_version: (2, 0),
                                          opengl_version: (2, 1),};
                let width = options.window_size.0;
                let height = options.window_size.1;
                let center = ((width as i32) / 2, (height as i32) / 2);
                let mut builder =
                    glutin::WindowBuilder::new().with_title(WINDOW_NAME).with_gl(gl);
                if options.fullscreen {
                    let monitor = glutin::get_primary_monitor();
                    let (width, height) = monitor.get_dimensions();
                    builder =
                        builder.with_fullscreen(monitor).with_dimensions(width,
                                                                         height);
                } else { builder = builder.with_dimensions(width, height); }
                let (window, device, mut factory, main_color, main_depth) =
                    gfx_window_glutin::init::<ColorFormat,
                                              gfx3d::DepthFormat>(builder);
                let encoder: gfx::Encoder<_, _> =
                    factory.create_command_buffer().into();
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 42u32,
                                            __file: "hsgraphics/init.rs",
                                            __module_path:
                                                "horde_survival::hsgraphics::init",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::hsgraphics::init",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["Platform name: "];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match (&device.get_info().platform_name,)
                                                                         {
                                                                         (__arg0,)
                                                                         =>
                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                      ::std::fmt::Debug::fmt)],
                                                                     }))
                    }
                };
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 43u32,
                                            __file: "hsgraphics/init.rs",
                                            __module_path:
                                                "horde_survival::hsgraphics::init",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::hsgraphics::init",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["GL version: "];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match (&device.get_info().version,)
                                                                         {
                                                                         (__arg0,)
                                                                         =>
                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                      ::std::fmt::Debug::fmt)],
                                                                     }))
                    }
                };
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 44u32,
                                            __file: "hsgraphics/init.rs",
                                            __module_path:
                                                "horde_survival::hsgraphics::init",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::hsgraphics::init",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["GLSL version: "];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match (&device.get_info().shading_language,)
                                                                         {
                                                                         (__arg0,)
                                                                         =>
                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                      ::std::fmt::Debug::fmt)],
                                                                     }))
                    }
                };
                let vs_2d_path = get_shader_version_path(&device, VS_2D_PATH);
                let vs_3d_path = get_shader_version_path(&device, VS_3D_PATH);
                let vs_gui_path =
                    get_shader_version_path(&device, VS_GUI_PATH);
                let fs_2d_path = get_shader_version_path(&device, FS_2D_PATH);
                let fs_3d_path = get_shader_version_path(&device, FS_3D_PATH);
                let fs_gui_path =
                    get_shader_version_path(&device, FS_GUI_PATH);
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 53u32,
                                            __file: "hsgraphics/init.rs",
                                            __module_path:
                                                "horde_survival::hsgraphics::init",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::hsgraphics::init",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["Creating PSO: 2d"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match ()
                                                                         {
                                                                         () =>
                                                                         [],
                                                                     }))
                    }
                };
                let pso2d =
                    {
                        match load_pso(&mut factory, vs_2d_path, fs_2d_path,
                                       Primitive::TriangleList,
                                       gfx2d::pipe::new()) {
                            Ok(val) => val,
                            Err(e) => {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 54u32,
                                                            __file:
                                                                "hsgraphics/init.rs",
                                                            __module_path:
                                                                "horde_survival::hsgraphics::init",};
                                    let lvl = $crate::LogLevel::Error;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hsgraphics::init",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &[""];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match (&e,)
                                                                                         {
                                                                                         (__arg0,)
                                                                                         =>
                                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                      ::std::fmt::Display::fmt)],
                                                                                     }))
                                    }
                                };
                                {
                                    $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/init.rs",
                                                                     54u32);
                                                                &_FILE_LINE
                                                            })
                                };
                            }
                        }
                    };
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 55u32,
                                            __file: "hsgraphics/init.rs",
                                            __module_path:
                                                "horde_survival::hsgraphics::init",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::hsgraphics::init",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["Creating PSO: 3d"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match ()
                                                                         {
                                                                         () =>
                                                                         [],
                                                                     }))
                    }
                };
                let pso3d =
                    {
                        match load_pso(&mut factory, vs_3d_path, fs_3d_path,
                                       Primitive::TriangleList,
                                       gfx3d::pipe::new()) {
                            Ok(val) => val,
                            Err(e) => {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 56u32,
                                                            __file:
                                                                "hsgraphics/init.rs",
                                                            __module_path:
                                                                "horde_survival::hsgraphics::init",};
                                    let lvl = $crate::LogLevel::Error;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hsgraphics::init",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &[""];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match (&e,)
                                                                                         {
                                                                                         (__arg0,)
                                                                                         =>
                                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                      ::std::fmt::Display::fmt)],
                                                                                     }))
                                    }
                                };
                                {
                                    $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/init.rs",
                                                                     56u32);
                                                                &_FILE_LINE
                                                            })
                                };
                            }
                        }
                    };
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 57u32,
                                            __file: "hsgraphics/init.rs",
                                            __module_path:
                                                "horde_survival::hsgraphics::init",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::hsgraphics::init",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["Creating PSO: gui"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match ()
                                                                         {
                                                                         () =>
                                                                         [],
                                                                     }))
                    }
                };
                let pso_gui =
                    {
                        match load_pso(&mut factory, vs_gui_path, fs_gui_path,
                                       Primitive::TriangleList,
                                       gfx_gui::pipe::new()) {
                            Ok(val) => val,
                            Err(e) => {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 58u32,
                                                            __file:
                                                                "hsgraphics/init.rs",
                                                            __module_path:
                                                                "horde_survival::hsgraphics::init",};
                                    let lvl = $crate::LogLevel::Error;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hsgraphics::init",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &[""];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match (&e,)
                                                                                         {
                                                                                         (__arg0,)
                                                                                         =>
                                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                      ::std::fmt::Display::fmt)],
                                                                                     }))
                                    }
                                };
                                {
                                    $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("hsgraphics/init.rs",
                                                                     58u32);
                                                                &_FILE_LINE
                                                            })
                                };
                            }
                        }
                    };
                let sampler_info =
                    tex::SamplerInfo::new(tex::FilterMethod::Bilinear,
                                          tex::WrapMode::Clamp);
                let sampler = factory.create_sampler(sampler_info);
                let aspect_ratio = (width as f32) / (height as f32);
                let camera =
                    get_camera(game.map.player_spawn.clone(),
                               START_CAMERA_ANGLE, aspect_ratio);
                let vbuf = factory.create_vertex_buffer(&[]);
                let vbuf2d = factory.create_vertex_buffer(&[]);
                let vbuf_gui = factory.create_vertex_buffer(&[]);
                let texture = load_texture_raw(&mut factory, [2, 2], &[0; 4]);
                let data =
                    gfx3d::pipe::Data{vbuf: vbuf,
                                      transform: [[0.0; 4]; 4],
                                      locals:
                                          factory.create_constant_buffer(1),
                                      color:
                                          (texture.clone(), sampler.clone()),
                                      out_color: main_color.clone(),
                                      out_depth: main_depth,};
                let data2d =
                    gfx2d::pipe::Data{vbuf: vbuf2d,
                                      color: (texture, sampler),
                                      out: main_color.clone(),};
                let data_gui =
                    gfx_gui::pipe::Data{vbuf: vbuf_gui, out: main_color,};
                let dpi_factor = window.hidpi_factor();
                let dpi = dpi_factor as u32;
                let (window_width, window_height) =
                    window.get_inner_size_pixels().unwrap();
                let (cache_width, cache_height) =
                    (window_width * dpi, window_height * dpi);
                let cache =
                    GlyphCache::new(cache_width, cache_height, 0.1, 0.1);
                let (cache_tex, cache_tex_view) =
                    texture::create_cache_texture(&mut factory, window_width,
                                                  window_height);
                let state =
                    GraphicsState{factory: factory,
                                  encoder: encoder,
                                  options: options,
                                  objects2d: Vec::new(),
                                  objects3d: Vec::new(),
                                  window_size: (width, height),
                                  window_center: center,
                                  should_close: false,
                                  cache:
                                      TextCache::new(cache, cache_tex,
                                                     cache_tex_view),
                                  pso2d: pso2d,
                                  pso3d: pso3d,
                                  pso_gui: pso_gui,
                                  data: data,
                                  data2d: data2d,
                                  data_gui: data_gui,
                                  aspect_ratio: aspect_ratio,
                                  camera: camera,
                                  assets: AssetLoader::new(),
                                  device: device,
                                  last_cursor_pos: center,
                                  pixel_size:
                                      (1.0 / (width as f32),
                                       1.0 / (height as f32)),
                                  dpi: dpi_factor,};
                (state, window)
            }
        }
    }
    pub use self::state::*;
    pub use self::object::*;
    pub use self::shapes::*;
    pub use self::gfx2d::CLEAR_COLOR;
    pub use self::texture::*;
    pub use self::camera::*;
    pub use self::options::*;
    pub use self::cache::*;
    use gfx::format;
    pub type ColorFormat = format::Srgba8;
    pub type SurfaceFormat = format::R8_G8_B8_A8;
    pub type FullFormat = (SurfaceFormat, format::Unorm);
}
#[macro_use]
mod world {
    #[macro_use]
    pub mod coords {
        use world::*;
        use cgmath::{Vector3, Point3};
        pub struct Coords {
            pub x: f64,
            pub y: f64,
            pub z: f64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Coords {
            #[inline]
            fn clone(&self) -> Coords {
                match *self {
                    Coords {
                    x: ref __self_0_0, y: ref __self_0_1, z: ref __self_0_2 }
                    =>
                    Coords{x: ::std::clone::Clone::clone(&(*__self_0_0)),
                           y: ::std::clone::Clone::clone(&(*__self_0_1)),
                           z: ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Coords {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Coords {
                    x: ref __self_0_0, y: ref __self_0_1, z: ref __self_0_2 }
                    => {
                        let mut builder = __arg_0.debug_struct("Coords");
                        let _ = builder.field("x", &&(*__self_0_0));
                        let _ = builder.field("y", &&(*__self_0_1));
                        let _ = builder.field("z", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl Coords {
            pub fn new(x: f64, y: f64, z: f64) -> Coords {
                Coords{x: x, y: y, z: z,}
            }
            pub fn origin() -> Coords { Coords::new(0.0, 0.0, 0.0) }
        }
        impl Coords {
            pub fn distance(&self, other: &Coords) -> f64 {
                ((self.x - other.x).powi(2) + (self.y - other.y).powi(2) +
                     (self.z - other.z).powi(2)).sqrt()
            }
            pub fn in_radius(&self, other: &Coords, radius: f64) -> bool {
                self.distance(other) <= radius
            }
            pub fn scale(&mut self, factor: f64) {
                self.x *= factor;
                self.y *= factor;
                self.z *= factor;
            }
            pub fn translate(&mut self, other: &Coords) {
                self.x += other.x;
                self.y += other.y;
                self.z += other.z;
            }
            pub fn move_forward(&mut self, heading: f64, distance: f64) {
                let radians = Direction(heading).wrap().as_radians();
                let mut slope_x = radians.cos();
                let mut slope_z = radians.sin();
                normalize(&mut slope_x, &mut slope_z);
                slope_x *= distance;
                slope_z *= distance;
                self.translate(&Coords::new(slope_x, 0.0, slope_z))
            }
            pub fn move_3d(&mut self, direction: (f64, f64), distance: f64) {
                let angle_x = Direction(direction.0).wrap().as_radians();
                let angle_y = Direction(direction.1).wrap().as_radians();
                let x = distance * angle_y.cos() * angle_x.sin();
                let y = distance * angle_x.cos();
                let z = distance * angle_y.sin() * angle_x.sin();
                self.translate(&Coords::new(x, y, z));
            }
            pub fn ray(&self, interval: f64, direction: (f64, f64)) -> Ray {
                Ray{coords: self.clone(),
                    interval: interval,
                    direction: direction,}
            }
            pub fn direction_to(&self, other: &Coords) -> (f64, f64) {
                let rise = self.y - other.y;
                let run = (self.x - other.x).abs();
                let rot_x = get_angle(rise, run);
                let rise = self.x - other.x;
                let run = self.z - other.z;
                let rot_y = get_angle2(run, rise);
                (rot_x, rot_y)
            }
            pub fn translated(&self, x: f64, y: f64, z: f64) -> Coords {
                let mut coords = self.clone();
                coords.x += x;
                coords.y += y;
                coords.z += z;
                coords
            }
            pub fn as_vector(&self) -> Vector3<f64> {
                Vector3::new(self.x, self.y, self.z)
            }
            pub fn as_point(&self) -> Point3<f64> {
                Point3::new(self.x, self.y, self.z)
            }
        }
    }
    pub mod direction {
        use std::f64::consts::PI;
        #[rustc_copy_clone_marker]
        pub struct Direction(pub f64);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Direction {
            #[inline]
            fn clone(&self) -> Direction {
                { let _: ::std::clone::AssertParamIsClone<f64>; *self }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Direction { }
        impl Direction {
            pub fn as_radians(self) -> f64 { self.0 * (PI / 180.0) }
            pub fn wrap(mut self) -> Direction {
                while self.0 >= 360.0 { self.0 -= 360.0; }
                while self.0 < 0.0 { self.0 += 360.0; }
                self
            }
        }
        pub fn get_degrees(radians: f64) -> f64 { radians * (180.0 / PI) }
        pub fn get_angle(rise: f64, run: f64) -> f64 {
            let hypotenuse = (rise.powi(2) + run.powi(2)).sqrt();
            let mut angle = get_degrees((run / hypotenuse).asin());
            angle = if rise > 0.0 { 90.0 + (90.0 - angle) } else { angle };
            if angle.is_nan() {
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 40u32,
                                            __file: "world/direction.rs",
                                            __module_path:
                                                "horde_survival::world::direction",};
                    let lvl = $crate::LogLevel::Warn;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::world::direction",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["get_angle returned NAN"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match ()
                                                                         {
                                                                         () =>
                                                                         [],
                                                                     }))
                    }
                };
                0.0
            } else { angle }
        }
        pub fn get_angle2(dx: f64, dy: f64) -> f64 {
            let mut angle = get_degrees(dx.atan2(dy));
            angle =
                if angle < 0.0 {
                    180.0 + (180.0 - angle.abs())
                } else { angle };
            if angle.is_nan() {
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 58u32,
                                            __file: "world/direction.rs",
                                            __module_path:
                                                "horde_survival::world::direction",};
                    let lvl = $crate::LogLevel::Warn;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl, "horde_survival::world::direction",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["get_angle2 returned NAN"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match ()
                                                                         {
                                                                         () =>
                                                                         [],
                                                                     }))
                    }
                };
                0.0
            } else { Direction(angle + 180.0).wrap().0 }
        }
    }
    pub mod vector {
        pub fn normalize(x: &mut f64, y: &mut f64) {
            let magnitude = magnitude(*x, *y);
            *x /= magnitude;
            *y /= magnitude;
        }
        pub fn magnitude(x: f64, y: f64) -> f64 {
            (x.powi(2) + y.powi(2)).sqrt()
        }
    }
    pub mod ray {
        use std::iter::Iterator;
        use world::Coords;
        pub struct Ray {
            pub coords: Coords,
            pub interval: f64,
            pub direction: (f64, f64),
        }
        impl Iterator for Ray {
            type
            Item
            =
            Coords;
            fn next(&mut self) -> Option<Self::Item> {
                let result = self.coords.clone();
                self.coords.move_3d(self.direction, self.interval);
                Some(result)
            }
        }
    }
    pub mod velocity {
        pub struct Velocity {
            pub component_x: f64,
            pub component_y: f64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Velocity {
            #[inline]
            fn clone(&self) -> Velocity {
                match *self {
                    Velocity {
                    component_x: ref __self_0_0, component_y: ref __self_0_1 }
                    =>
                    Velocity{component_x:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             component_y:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Velocity {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Velocity {
                    component_x: ref __self_0_0, component_y: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Velocity");
                        let _ = builder.field("component_x", &&(*__self_0_0));
                        let _ = builder.field("component_y", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl Velocity {
            pub fn zero() -> Velocity {
                Velocity{component_x: 0.0, component_y: 0.0,}
            }
            pub fn accelerate(&mut self, accel_x: f64, accel_y: f64) {
                self.component_x += accel_x;
                self.component_y += accel_y;
            }
        }
    }
    pub use self::coords::Coords;
    pub use self::direction::*;
    pub use self::vector::*;
    pub use self::ray::Ray;
    pub use self::velocity::Velocity;
}
mod utils {
    use glutin::{Window, CursorState};
    use std::time::Duration;
    pub fn millis(duration: Duration) -> u64 {
        let secs = duration.as_secs();
        let nanos = duration.subsec_nanos() as u64;
        secs * 1000 + nanos / 1000000
    }
    pub fn set_cursor_state(window: &Window, cursor_state: CursorState) {
        if let Err(_) = window.set_cursor_state(cursor_state) {
            {
                static _LOC: $crate::LogLocation =
                    $crate::LogLocation{__line: 14u32,
                                        __file: "utils.rs",
                                        __module_path:
                                            "horde_survival::utils",};
                let lvl = $crate::LogLevel::Warn;
                if lvl <= $crate::__static_max_level() &&
                       lvl <= $crate::max_log_level() {
                    $crate::__log(lvl, "horde_survival::utils", &_LOC,
                                  ::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["Failed to set cursor state to "];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match (&cursor_state,)
                                                                     {
                                                                     (__arg0,)
                                                                     =>
                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                  ::std::fmt::Debug::fmt)],
                                                                 }))
                }
            };
        }
    }
}
mod player {
    pub mod class {
        pub enum Class { Warrior, }
    }
    pub mod input {
        use hscontrols::movement;
        pub struct Input {
            pub forward: bool,
            pub left: bool,
            pub right: bool,
            pub back: bool,
        }
        impl Input {
            pub fn new() -> Input {
                Input{forward: false, left: false, right: false, back: false,}
            }
            pub fn movement_key_pressed(&self) -> bool {
                self.forward || self.left || self.right || self.back
            }
            pub fn movement_offset(&self) -> f64 {
                movement::get_movement_offset(self.forward, self.left,
                                              self.right, self.back)
            }
        }
    }
    mod abilities {
        use entity::*;
        use player::Player;
        use consts::balance::*;
        use hslog::*;
        pub fn warrior_ability_0(player: &mut Player,
                                 entities: &mut Vec<Entity>) {
            let player_entity =
                entities.iter_mut().find(|e|
                                             e.id ==
                                                 player.entity_id).expect("Player entity not found");
            player_entity.damage_taken_mods.push(WARRIOR_FORTIFY);
        }
        pub fn warrior_ability_1(player: &mut Player,
                                 entities: &mut Vec<Entity>) {
            let coords =
                {
                    {
                        if entities.iter().find(|e|
                                                    e.id ==
                                                        player.entity_id).can_unwrap()
                           {
                            entities.iter().find(|e|
                                                     e.id ==
                                                         player.entity_id).unwrap()
                        } else {
                            {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 13u32,
                                                            __file:
                                                                "player/abilities.rs",
                                                            __module_path:
                                                                "horde_survival::player::abilities",};
                                    let lvl = $crate::LogLevel::Error;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::player::abilities",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &["Player entity not found"];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match ()
                                                                                         {
                                                                                         ()
                                                                                         =>
                                                                                         [],
                                                                                     }))
                                    }
                                };
                                {
                                    $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("player/abilities.rs",
                                                                     13u32);
                                                                &_FILE_LINE
                                                            })
                                };
                            };
                        }
                    };
                }.coords.clone();
            for entity in
                entities.iter_mut().filter(|e|
                                               e.team != Team::Players &&
                                                   e.coords.in_radius(&coords,
                                                                      WARRIOR_MAIM_RADIUS))
                {
                entity.damage_mods.push(WARRIOR_MAIM_DAMAGE);
                entity.movespeed_mods.push(WARRIOR_MAIM_SLOW);
            }
        }
        pub fn warrior_ability_2(player: &mut Player,
                                 entities: &mut Vec<Entity>) {
            let player_entity =
                entities.iter_mut().find(|e|
                                             e.id ==
                                                 player.entity_id).expect("Player entity not found");
            player_entity.as_mods.push(WARRIOR_RAGE_AS);
            player_entity.damage_mods.push(WARRIOR_RAGE_DAMAGE);
        }
        #[allow(needless_borrow)]
        pub fn warrior_ability_3(player: &mut Player,
                                 entities: &mut Vec<Entity>) {
            let coords;
            let player_index;
            {
                let (i, entity) =
                    {
                        {
                            if entities.iter().enumerate().find(|&(_, ref e)|
                                                                    e.id ==
                                                                        player.entity_id).can_unwrap()
                               {
                                entities.iter().enumerate().find(|&(_, ref e)|
                                                                     e.id ==
                                                                         player.entity_id).unwrap()
                            } else {
                                {
                                    {
                                        static _LOC: $crate::LogLocation =
                                            $crate::LogLocation{__line: 36u32,
                                                                __file:
                                                                    "player/abilities.rs",
                                                                __module_path:
                                                                    "horde_survival::player::abilities",};
                                        let lvl = $crate::LogLevel::Error;
                                        if lvl <= $crate::__static_max_level()
                                               &&
                                               lvl <= $crate::max_log_level()
                                           {
                                            $crate::__log(lvl,
                                                          "horde_survival::player::abilities",
                                                          &_LOC,
                                                          ::std::fmt::Arguments::new_v1({
                                                                                            static __STATIC_FMTSTR:
                                                                                                   &'static [&'static str]
                                                                                                   =
                                                                                                &["Player entity not found"];
                                                                                            __STATIC_FMTSTR
                                                                                        },
                                                                                        &match ()
                                                                                             {
                                                                                             ()
                                                                                             =>
                                                                                             [],
                                                                                         }))
                                        }
                                    };
                                    {
                                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("player/abilities.rs",
                                                                         36u32);
                                                                    &_FILE_LINE
                                                                })
                                    };
                                };
                            }
                        };
                    };
                coords = entity.coords.clone();
                player_index = i;
            }
            let indices =
                entities.iter().enumerate().filter_map(|(i, ref e)| {
                                                       if e.team !=
                                                              Team::Players &&
                                                              e.coords.in_radius(&coords,
                                                                                 WARRIOR_EXECUTE_RADIUS)
                                                          {
                                                           Some(i)
                                                       } else { None }
                                                   }).collect::<Vec<_>>();
            for i in indices {
                let mut clone = entities[i].clone();
                clone.damage(WARRIOR_EXECUTE_DAMAGE, i, player_index,
                             entities, player);
                let entity =
                    {
                        {
                            if entities.iter_mut().find(|e|
                                                            e.id ==
                                                                clone.id).can_unwrap()
                               {
                                entities.iter_mut().find(|e|
                                                             e.id ==
                                                                 clone.id).unwrap()
                            } else {
                                {
                                    {
                                        static _LOC: $crate::LogLocation =
                                            $crate::LogLocation{__line: 57u32,
                                                                __file:
                                                                    "player/abilities.rs",
                                                                __module_path:
                                                                    "horde_survival::player::abilities",};
                                        let lvl = $crate::LogLevel::Error;
                                        if lvl <= $crate::__static_max_level()
                                               &&
                                               lvl <= $crate::max_log_level()
                                           {
                                            $crate::__log(lvl,
                                                          "horde_survival::player::abilities",
                                                          &_LOC,
                                                          ::std::fmt::Arguments::new_v1({
                                                                                            static __STATIC_FMTSTR:
                                                                                                   &'static [&'static str]
                                                                                                   =
                                                                                                &["Call to damage removed entity"];
                                                                                            __STATIC_FMTSTR
                                                                                        },
                                                                                        &match ()
                                                                                             {
                                                                                             ()
                                                                                             =>
                                                                                             [],
                                                                                         }))
                                        }
                                    };
                                    {
                                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("player/abilities.rs",
                                                                         57u32);
                                                                    &_FILE_LINE
                                                                })
                                    };
                                };
                            }
                        };
                    };
                *entity = clone;
                if entity.is_dead() { player.give_gold(entity.bounty); }
            }
        }
    }
    mod inventory {
        use entity::Entity;
        use player::Player;
        use items::*;
        impl Player {
            pub fn equip_from_inventory(&mut self, id: usize,
                                        entity: &mut Entity) {
                match self.inventory.get(&id) {
                    Some(item) => {
                        match *item {
                            Item::Weapon(ref weapon) =>
                            entity.current_weapon = weapon.clone(),
                            Item::Armor(ref armor) =>
                            entity.armor[armor.slot as i32 as usize] = *armor,
                        }
                    }
                    None => {
                        {
                            static _LOC: $crate::LogLocation =
                                $crate::LogLocation{__line: 14u32,
                                                    __file:
                                                        "player/inventory.rs",
                                                    __module_path:
                                                        "horde_survival::player::inventory",};
                            let lvl = $crate::LogLevel::Error;
                            if lvl <= $crate::__static_max_level() &&
                                   lvl <= $crate::max_log_level() {
                                $crate::__log(lvl,
                                              "horde_survival::player::inventory",
                                              &_LOC,
                                              ::std::fmt::Arguments::new_v1({
                                                                                static __STATIC_FMTSTR:
                                                                                       &'static [&'static str]
                                                                                       =
                                                                                    &["Item not found: "];
                                                                                __STATIC_FMTSTR
                                                                            },
                                                                            &match (&id,)
                                                                                 {
                                                                                 (__arg0,)
                                                                                 =>
                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                              ::std::fmt::Display::fmt)],
                                                                             }))
                            }
                        };
                        {
                            $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("player/inventory.rs",
                                                             14u32);
                                                        &_FILE_LINE
                                                    })
                        };
                    }
                }
            }
            pub fn give_item(&mut self, item: Item) {
                let new_id = self.inventory.len();
                self.inventory.insert(new_id, item);
            }
            pub fn buy_item(&mut self, item: &ShopItem) -> bool {
                if self.gold >= item.price {
                    self.give_item(item.item.clone());
                    true
                } else { false }
            }
        }
    }
    pub use self::class::Class;
    use player::abilities::*;
    use player::input::Input;
    use world::Coords;
    use items::*;
    use entity::*;
    use consts::*;
    use std::collections::HashMap;
    pub struct Player {
        pub gold: usize,
        pub class: Class,
        pub inventory: HashMap<usize, Item>,
        pub dead: bool,
        pub entity_id: usize,
        pub player_id: usize,
        pub current_cooldowns: [usize; 4],
        pub cooldown_mods: Vec<Modifier>,
        pub input: Input,
        pub left_click: bool,
        pub mouse: (i32, i32),
        pub direction: (f64, f64),
        pub coords: Coords,
    }
    impl Player {
        pub fn new(entity_id: usize, player_id: usize, class: Class,
                   coords: Coords) -> Player {
            Player{entity_id: entity_id,
                   player_id: player_id,
                   gold: 0,
                   class: class,
                   current_cooldowns: [0; 4],
                   cooldown_mods: Vec::new(),
                   inventory: base_inventory(),
                   dead: false,
                   left_click: false,
                   mouse: (0, 0),
                   input: Input::new(),
                   direction: START_CAMERA_ANGLE,
                   coords: coords,}
        }
    }
    impl Player {
        pub fn give_gold(&mut self, gold: usize) { self.gold += gold; }
        pub fn update_cooldowns(&mut self) {
            for cooldown in &mut self.current_cooldowns {
                if *cooldown > 0 { *cooldown -= 1; }
            }
        }
        pub fn start_cooldown(&mut self, id: usize) {
            let base =
                match self.class { Class::Warrior => WARRIOR_COOLDOWNS[id], };
            self.current_cooldowns[id] =
                apply(&self.cooldown_mods, base as f64) as usize;
        }
        pub fn reset_controls(&mut self) {
            self.input = Input::new();
            self.left_click = false;
        }
    }
    impl Player {
        pub fn ability_0(&mut self, entities: &mut Vec<Entity>) {
            let mut is_casting = false;
            if self.current_cooldowns[0] == 0 {
                let player_entity =
                    entities.iter_mut().find(|e|
                                                 e.id ==
                                                     self.entity_id).expect("Player entity not found");
                is_casting = player_entity.animations.is_casting(1);
                if player_entity.animations.can_cast(1) && !is_casting {
                    player_entity.animations.start(1, WARRIOR_PRE_0,
                                                   WARRIOR_POST_0);
                }
            }
            if is_casting {
                self.start_cooldown(0);
                match self.class {
                    Class::Warrior => { warrior_ability_0(self, entities); }
                }
            }
        }
        pub fn ability_1(&mut self, entities: &mut Vec<Entity>) {
            let mut is_casting = false;
            if self.current_cooldowns[1] == 0 {
                let player_entity =
                    entities.iter_mut().find(|e|
                                                 e.id ==
                                                     self.entity_id).expect("Player entity not found");
                is_casting = player_entity.animations.is_casting(2);
                if player_entity.animations.can_cast(2) && !is_casting {
                    player_entity.animations.start(2, WARRIOR_PRE_1,
                                                   WARRIOR_POST_1);
                }
            }
            if is_casting {
                self.start_cooldown(1);
                match self.class {
                    Class::Warrior => { warrior_ability_1(self, entities); }
                }
            }
        }
        pub fn ability_2(&mut self, entities: &mut Vec<Entity>) {
            let mut is_casting = false;
            if self.current_cooldowns[2] == 0 {
                let player_entity =
                    entities.iter_mut().find(|e|
                                                 e.id ==
                                                     self.entity_id).expect("Player entity not found");
                is_casting = player_entity.animations.is_casting(3);
                if player_entity.animations.can_cast(3) && !is_casting {
                    player_entity.animations.start(3, WARRIOR_PRE_2,
                                                   WARRIOR_POST_2);
                }
            }
            if is_casting {
                self.start_cooldown(2);
                match self.class {
                    Class::Warrior => { warrior_ability_2(self, entities); }
                }
            }
        }
        pub fn ability_3(&mut self, entities: &mut Vec<Entity>) {
            let mut is_casting = false;
            if self.current_cooldowns[3] == 0 {
                let player_entity =
                    entities.iter_mut().find(|e|
                                                 e.id ==
                                                     self.entity_id).expect("Player entity not found");
                is_casting = player_entity.animations.is_casting(4);
                if player_entity.animations.can_cast(4) && !is_casting {
                    player_entity.animations.start(4, WARRIOR_PRE_3,
                                                   WARRIOR_POST_3);
                }
            }
            if is_casting {
                self.start_cooldown(3);
                match self.class {
                    Class::Warrior => { warrior_ability_3(self, entities); }
                }
            }
        }
    }
}
mod consts {
    #[macro_use]
    pub mod misc {
        use items::Item;
        use consts::items::armor::*;
        use consts::items::weapon::*;
        use std::collections::HashMap;
        pub const TPS: u64 = 30;
        pub const TPS_FLOAT: f64 = TPS as f64;
        pub const GUI_MAX_FPS: u64 = 30;
        pub const BASE_INVENTORY: [Item; 5] =
            [Item::Armor(HEAD_NONE), Item::Armor(BODY_NONE),
             Item::Armor(LEGS_NONE), Item::Armor(FEET_NONE),
             Item::Weapon(UNARMED)];
        pub fn base_inventory() -> HashMap<usize, Item> {
            let mut inventory = HashMap::new();
            for (i, item) in BASE_INVENTORY.iter().cloned().enumerate() {
                inventory.insert(i, item);
            }
            inventory
        }
        pub const CRASH_MESSAGE: &'static str = "Horde Survival has crashed";
    }
    pub mod balance {
        pub mod items {
            pub mod armor {
                use items::*;
                #[allow(dead_code)]
                pub const HEAD_NONE: $crate::items::armor::Armor =
                    {
                        $crate::items::armor::Armor{name: "None",
                                                    multiplier: 1.0,
                                                    when_hit: None,
                                                    slot: ArmorSlot::Head,}
                    };
                #[allow(dead_code)]
                pub const SHOP_HEAD_NONE: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Armor(HEAD_NONE),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const BODY_NONE: $crate::items::armor::Armor =
                    {
                        $crate::items::armor::Armor{name: "None",
                                                    multiplier: 1.0,
                                                    when_hit: None,
                                                    slot: ArmorSlot::Body,}
                    };
                #[allow(dead_code)]
                pub const SHOP_BODY_NONE: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Armor(BODY_NONE),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const LEGS_NONE: $crate::items::armor::Armor =
                    {
                        $crate::items::armor::Armor{name: "None",
                                                    multiplier: 1.0,
                                                    when_hit: None,
                                                    slot: ArmorSlot::Legs,}
                    };
                #[allow(dead_code)]
                pub const SHOP_LEGS_NONE: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Armor(LEGS_NONE),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const FEET_NONE: $crate::items::armor::Armor =
                    {
                        $crate::items::armor::Armor{name: "None",
                                                    multiplier: 1.0,
                                                    when_hit: None,
                                                    slot: ArmorSlot::Feet,}
                    };
                #[allow(dead_code)]
                pub const SHOP_FEET_NONE: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Armor(FEET_NONE),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const HEAL: $crate::items::armor::Armor =
                    {
                        $crate::items::armor::Armor{name: "Healing Armor",
                                                    multiplier: 0.8,
                                                    when_hit:
                                                        Some(&armor_effect_heal),
                                                    slot: ArmorSlot::Body,}
                    };
                #[allow(dead_code)]
                pub const SHOP_HEAL: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Armor(HEAL),
                                                      price: 1500,}
                    };
            }
            pub mod weapon {
                use items::*;
                #[allow(dead_code)]
                pub const TEST_SWORD: $crate::items::weapon::Weapon =
                    {
                        $crate::items::weapon::Weapon{name: "Test Sword",
                                                      damage: 25.0,
                                                      range: 0.6,
                                                      attack_speed: 1.0,
                                                      weapon_type:
                                                          WeaponType::MeleeArea,
                                                      anim_pre:
                                                          (0.5 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      anim_post:
                                                          (0.2 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      on_hit: None,}
                    };
                #[allow(dead_code)]
                pub const SHOP_TEST_SWORD: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Weapon(TEST_SWORD),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const TEST_BOW: $crate::items::weapon::Weapon =
                    {
                        $crate::items::weapon::Weapon{name: "Test Bow",
                                                      damage: 60.0,
                                                      range: 6.0,
                                                      attack_speed: 0.8,
                                                      weapon_type:
                                                          WeaponType::RangedProjectile,
                                                      anim_pre:
                                                          (0.3 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      anim_post:
                                                          (0.15 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      on_hit: None,}
                    };
                #[allow(dead_code)]
                pub const SHOP_TEST_BOW: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Weapon(TEST_BOW),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const TEST_WAND: $crate::items::weapon::Weapon =
                    {
                        $crate::items::weapon::Weapon{name: "Test Wand",
                                                      damage: 45.0,
                                                      range: 3.0,
                                                      attack_speed: 1.2,
                                                      weapon_type:
                                                          WeaponType::RangedLinear,
                                                      anim_pre:
                                                          (0.5 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      anim_post:
                                                          (0.2 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      on_hit: None,}
                    };
                #[allow(dead_code)]
                pub const SHOP_TEST_WAND: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Weapon(TEST_WAND),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const TEST_GUN: $crate::items::weapon::Weapon =
                    {
                        $crate::items::weapon::Weapon{name: "Test Gun",
                                                      damage: 20.0,
                                                      range: 100.0,
                                                      attack_speed: 10.0,
                                                      weapon_type:
                                                          WeaponType::RangedLinear,
                                                      anim_pre:
                                                          (0.0 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      anim_post:
                                                          (0.1 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      on_hit: None,}
                    };
                #[allow(dead_code)]
                pub const SHOP_TEST_GUN: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Weapon(TEST_GUN),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const UNARMED: $crate::items::weapon::Weapon =
                    {
                        $crate::items::weapon::Weapon{name: "Unarmed",
                                                      damage: 60.0,
                                                      range: 0.4,
                                                      attack_speed: 1.0,
                                                      weapon_type:
                                                          WeaponType::MeleeLine,
                                                      anim_pre:
                                                          (0.3 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      anim_post:
                                                          (0.15 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      on_hit: None,}
                    };
                #[allow(dead_code)]
                pub const SHOP_UNARMED: $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Weapon(UNARMED),
                                                      price: 0,}
                    };
                #[allow(dead_code)]
                pub const LIGHTNING_SWORD_2: $crate::items::weapon::Weapon =
                    {
                        $crate::items::weapon::Weapon{name:
                                                          "Lightning Sword 2",
                                                      damage: 0.0,
                                                      range: 6.0,
                                                      attack_speed: 1.0,
                                                      weapon_type:
                                                          WeaponType::MeleeLine,
                                                      anim_pre:
                                                          (0.4 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      anim_post:
                                                          (0.3 *
                                                               $crate::consts::TPS_FLOAT)
                                                              as usize,
                                                      on_hit:
                                                          Some(&weapon_effect_instant_kill_10),}
                    };
                #[allow(dead_code)]
                pub const SHOP_LIGHTNING_SWORD_2:
                          $crate::items::shop::ShopItem =
                    {
                        $crate::items::shop::ShopItem{item:
                                                          &$crate::items::Item::Weapon(LIGHTNING_SWORD_2),
                                                      price: 2500,}
                    };
            }
            pub mod effects {
                #![allow(dead_code)]
                pub mod armor {
                    pub const ARMOR_EFFECT_HEAL_AMOUNT: f64 = 200.0;
                    pub const ARMOR_EFFECT_HEAL_RANGE: i32 = 1;
                }
                pub mod weapon {
                    pub const WEAPON_EFFECT_LIGHTNING_SWORD_2_RANGE: i32 = 10;
                }
                pub use self::armor::*;
                pub use self::weapon::*;
            }
        }
        pub mod gold {
            pub const BASE_BOUNTY: usize = 10;
            pub const BOUNTY_GROWTH: f64 = 0.4;
        }
        pub mod entity {
            use entity::EntityType;
            pub const DEAD_ENTITY_HEALTH: f64 = -1000000.0;
            pub const INFINITE_LIFETIME: usize = 0;
            pub const BASE_MOVESPEED: f64 = 0.05;
            pub const GLOBAL_ATTACK_TIME: f64 = 1.0;
            pub const DEFAULT_DIRECTION: (f64, f64) = (90.0, 0.0);
            pub const MELEE_LINE_RADIUS: f64 = 0.3;
            pub const MELEE_LINE_INTERVAL: f64 = MELEE_LINE_RADIUS / 2.0;
            pub const RANGED_LINEAR_LIFETIME: usize =
                (1.5 * $crate::consts::TPS_FLOAT) as usize;
            pub const RANGED_LINEAR_SPEED: f64 = 0.5;
            pub const RANGED_ARC_SPEED: f64 = 0.2;
            pub const RANGED_RADIUS: f64 = 0.175;
            pub const RANGED_INTERVAL: f64 = RANGED_RADIUS / 2.0;
            pub const PROJECTILE_SPAWN_OFFSET: f64 = -0.1;
            pub const PLAYER_HEALTH: f64 = 100.0;
            pub const MONSTER_SPAWN_RADIUS: f64 = 2.5;
            pub fn get_movespeed(entity_type: &EntityType) -> Option<f64> {
                match *entity_type {
                    EntityType::Player => Some(1.5),
                    EntityType::Zombie => Some(0.75),
                    _ => None,
                }
            }
            pub fn get_monster_health(entity_type: &EntityType) -> f64 {
                match *entity_type { EntityType::Zombie => 100.0, _ => 0.0, }
            }
        }
        pub mod abilities {
            use entity::modifiers::*;
            pub const WARRIOR_COOLDOWNS: [usize; 4] =
                [(4.0 * $crate::consts::TPS_FLOAT) as usize,
                 (4.0 * $crate::consts::TPS_FLOAT) as usize,
                 (4.0 * $crate::consts::TPS_FLOAT) as usize,
                 (0.0 * $crate::consts::TPS_FLOAT) as usize];
            pub const WARRIOR_PRE_0: usize =
                (1.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_PRE_1: usize =
                (1.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_PRE_2: usize =
                (1.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_PRE_3: usize =
                (0.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_POST_0: usize =
                (1.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_POST_1: usize =
                (1.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_POST_2: usize =
                (1.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_POST_3: usize =
                (0.0 * $crate::consts::TPS_FLOAT) as usize;
            pub const WARRIOR_FORTIFY: Modifier =
                {
                    {
                        Modifier{value: 0.5,
                                 timer:
                                     (3.0 * $crate::consts::TPS_FLOAT) as
                                         usize,
                                 kind:
                                     $crate::entity::modifiers::ModifierKind::Multiplicative,}
                    }
                };
            pub const WARRIOR_MAIM_DAMAGE: Modifier =
                {
                    {
                        Modifier{value: 0.65,
                                 timer:
                                     (4.0 * $crate::consts::TPS_FLOAT) as
                                         usize,
                                 kind:
                                     $crate::entity::modifiers::ModifierKind::Multiplicative,}
                    }
                };
            pub const WARRIOR_MAIM_SLOW: Modifier =
                {
                    {
                        Modifier{value: 0.65,
                                 timer:
                                     (4.0 * $crate::consts::TPS_FLOAT) as
                                         usize,
                                 kind:
                                     $crate::entity::modifiers::ModifierKind::Multiplicative,}
                    }
                };
            pub const WARRIOR_MAIM_RADIUS: f64 = 1.5;
            pub const WARRIOR_RAGE_AS: Modifier =
                {
                    {
                        Modifier{value: 1.0,
                                 timer:
                                     (4.0 * $crate::consts::TPS_FLOAT) as
                                         usize,
                                 kind:
                                     $crate::entity::modifiers::ModifierKind::Multiplier,}
                    }
                };
            pub const WARRIOR_RAGE_DAMAGE: Modifier =
                {
                    {
                        Modifier{value: 1.0,
                                 timer:
                                     (4.0 * $crate::consts::TPS_FLOAT) as
                                         usize,
                                 kind:
                                     $crate::entity::modifiers::ModifierKind::Multiplier,}
                    }
                };
            pub const WARRIOR_EXECUTE_DAMAGE: f64 = 1000.0;
            pub const WARRIOR_EXECUTE_RADIUS: f64 = 1.5;
        }
        pub mod ai_control {
            pub const RANGE_THRESHOLD: f64 = 0.75;
            pub const RANGE_TOO_CLOSE_THRESHOLD: f64 = 0.15;
            pub const PROJECTILE_LEARNING_RATE: f64 = 0.3;
            pub const ERROR_RESET_THRESHOLD: usize = 3;
            pub const ERROR_INCREASE_THRESHOLD: f64 = 2.5;
        }
        pub mod hitbox {
            use cgmath::Point3;
            use collision::Aabb3;
            use entity::{EntityType, Hitbox};
            use world::Coords;
            pub fn get_hitbox(entity_type: &EntityType, coords: &Coords)
             -> Hitbox {
                let (mut a, mut b) =
                    match *entity_type {
                        EntityType::Player | EntityType::Zombie =>
                        (Point3::new(-0.12f64, -0.8, -0.12),
                         Point3::new(0.12f64, 0.0, 0.12)),
                        _ =>
                        (Point3::new(0f64, 0.0, 0.0),
                         Point3::new(0f64, 0.0, 0.0)),
                    };
                let coords = coords.as_vector();
                a += coords;
                b += coords;
                Aabb3::new(a, b)
            }
            pub fn get_entity_box_size(entity_type: &EntityType) -> f32 {
                match *entity_type {
                    EntityType::Player | EntityType::Zombie => 0.1,
                    EntityType::FlyingBallLinear | EntityType::FlyingBallArc
                    => 0.05,
                }
            }
        }
        pub mod wave {
            pub const BASE_WAVE_SIZE: usize = 4;
            pub const WAVE_SIZE_GROWTH: usize = 2;
        }
        pub use self::items::armor::*;
        pub use self::items::weapon::*;
        pub use self::items::effects::armor::*;
        pub use self::items::effects::weapon::*;
        pub use self::gold::*;
        pub use self::entity::*;
        pub use self::abilities::*;
        pub use self::ai_control::*;
        pub use self::hitbox::*;
        pub use self::wave::*;
    }
    pub mod controls {
        pub const DEFAULT_MOUSE_SENSITIVITY: f64 = 0.075;
    }
    pub mod graphics {
        pub mod window {
            pub const WINDOW_NAME: &'static str = "Horde Survival";
        }
        pub mod crosshair {
            pub const CROSSHAIR_OBJECT_ID: usize = 2;
            pub const CROSSHAIR_SIZE: f32 = 10.0;
        }
        mod camera {
            pub const VERTICAL_FOV: f32 = 45.0;
            pub const START_CAMERA_ANGLE: (f64, f64) = (90.0, 0.0);
        }
        pub use self::window::*;
        pub use self::camera::*;
        pub use self::crosshair::*;
        pub const FLOOR_HEIGHT: f32 = 0.4;
        pub const UPDATE_THRESHOLD: f64 = 0.05;
        pub const ENTITY_OBJECT_ID: usize = 1;
        pub const GUI_CLEAR_COLOR: [f32; 4] = [0.5, 0.5, 0.5, 1.0];
        pub const LOADING_CLEAR_COLOR: [f32; 4] = [0.5, 0.5, 0.5, 1.0];
    }
    pub mod physics {
        use consts::misc::TPS;
        pub const G: f64 = 0.3;
        pub const GRAVITY: f64 = G / (TPS as f64);
    }
    pub mod log_str {
        pub const LOG_FILE: &'static str = "log.txt";
    }
    pub mod scale {
        pub const WORLD_SCALE: f32 = 1.0;
    }
    pub mod defaults {
        pub const WINDOW_HEIGHT: u32 = 900;
        pub const WINDOW_WIDTH: u32 = 1200;
    }
    pub mod shader {
        pub const VS_2D_PATH: &'static str = "v_2d.glsl";
        pub const FS_2D_PATH: &'static str = "f_2d.glsl";
        pub const VS_3D_PATH: &'static str = "v_3d.glsl";
        pub const FS_3D_PATH: &'static str = "v_2d.glsl";
        pub const VS_GUI_PATH: &'static str = "v_gui.glsl";
        pub const FS_GUI_PATH: &'static str = "f_gui.glsl";
    }
    pub use self::balance::*;
    pub use self::controls::*;
    pub use self::graphics::*;
    pub use self::misc::*;
    pub use self::physics::*;
    pub use self::scale::*;
    pub use self::shader::*;
    use world::Coords;
    pub const TEST_SPAWN_POINTS: ([Coords; 2], [f64; 2]) =
        ([{ Coords{x: 5.0, y: 0.0, z: 5.0,} },
          { Coords{x: -5.0, y: 0.0, z: -5.0,} }], [1.0, 1.0]);
}
mod hscontrols {
    pub mod mouse {
        use glutin::Window;
        use hsgraphics::GraphicsState;
        pub fn center_mouse(state: &mut GraphicsState, mouse: &mut (i32, i32),
                            window: &Window) {
            let (x, y) = state.window_center;
            mouse.0 = state.last_cursor_pos.0 - x;
            mouse.1 = state.last_cursor_pos.1 - y;
            state.last_cursor_pos = state.window_center;
            if window.set_cursor_position(x, y).is_err() {
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 14u32,
                                            __file: "hscontrols/mouse.rs",
                                            __module_path:
                                                "horde_survival::hscontrols::mouse",};
                    let lvl = $crate::LogLevel::Error;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl,
                                      "horde_survival::hscontrols::mouse",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["Failed to set cursor position to (",
                                                                              ", ",
                                                                              ")"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match (&x,
                                                                            &y)
                                                                         {
                                                                         (__arg0,
                                                                          __arg1)
                                                                         =>
                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                      ::std::fmt::Display::fmt),
                                                                          ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                      ::std::fmt::Display::fmt)],
                                                                     }))
                    }
                };
            }
        }
    }
    pub mod movement {
        #[allow(match_same_arms)]
        pub fn get_movement_offset(forward: bool, left: bool, right: bool,
                                   backward: bool) -> f64 {
            match (forward, left, right, backward) {
                (true, false, false, false) => 0.0,
                (false, false, true, false) => 270.0,
                (false, true, false, false) => 90.0,
                (false, false, false, true) => 180.0,
                (true, false, true, false) => 315.0,
                (true, true, false, false) => 45.0,
                (false, false, true, true) => 225.0,
                (false, true, false, true) => 135.0,
                (true, false, false, true) => 0.0,
                (false, true, true, false) => 90.0,
                (false, true, true, true) => 180.0,
                (true, true, false, true) => 90.0,
                (true, false, true, true) => 270.0,
                (true, true, true, false) => 0.0,
                (true, true, true, true) => 0.0,
                (false, false, false, false) => {
                    {
                        $crate::rt::begin_panic("internal error: entered unreachable code",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("hscontrols/movement.rs",
                                                         28u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
        }
    }
    pub mod input {
        use glutin::*;
        use player::*;
        use entity::Entity;
        pub fn handle_keyboard_input(key: Option<VirtualKeyCode>,
                                     state: ElementState, scan_code: ScanCode,
                                     entities: &mut Vec<Entity>,
                                     player: &mut Player) {
            let key =
                match key {
                    Some(key) => key,
                    None => {
                        {
                            static _LOC: $crate::LogLocation =
                                $crate::LogLocation{__line: 15u32,
                                                    __file:
                                                        "hscontrols/input.rs",
                                                    __module_path:
                                                        "horde_survival::hscontrols::input",};
                            let lvl = $crate::LogLevel::Warn;
                            if lvl <= $crate::__static_max_level() &&
                                   lvl <= $crate::max_log_level() {
                                $crate::__log(lvl,
                                              "horde_survival::hscontrols::input",
                                              &_LOC,
                                              ::std::fmt::Arguments::new_v1({
                                                                                static __STATIC_FMTSTR:
                                                                                       &'static [&'static str]
                                                                                       =
                                                                                    &["VirtualKeyCode not found for key: "];
                                                                                __STATIC_FMTSTR
                                                                            },
                                                                            &match (&scan_code,)
                                                                                 {
                                                                                 (__arg0,)
                                                                                 =>
                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                              ::std::fmt::Debug::fmt)],
                                                                             }))
                            }
                        };
                        return;
                    }
                };
            match state {
                ElementState::Pressed => {
                    match key {
                        VirtualKeyCode::W => player.input.forward = true,
                        VirtualKeyCode::A => player.input.left = true,
                        VirtualKeyCode::S => player.input.back = true,
                        VirtualKeyCode::D => player.input.right = true,
                        VirtualKeyCode::Key1 => {
                            if player.dead {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 31u32,
                                                            __file:
                                                                "hscontrols/input.rs",
                                                            __module_path:
                                                                "horde_survival::hscontrols::input",};
                                    let lvl = $crate::LogLevel::Info;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hscontrols::input",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &["Ability 0: dead"];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match ()
                                                                                         {
                                                                                         ()
                                                                                         =>
                                                                                         [],
                                                                                     }))
                                    }
                                };
                            } else { player.ability_0(entities); }
                        }
                        VirtualKeyCode::Key2 => {
                            if player.dead {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 38u32,
                                                            __file:
                                                                "hscontrols/input.rs",
                                                            __module_path:
                                                                "horde_survival::hscontrols::input",};
                                    let lvl = $crate::LogLevel::Info;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hscontrols::input",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &["Ability 1: dead"];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match ()
                                                                                         {
                                                                                         ()
                                                                                         =>
                                                                                         [],
                                                                                     }))
                                    }
                                };
                            } else { player.ability_1(entities); }
                        }
                        VirtualKeyCode::Key3 => {
                            if player.dead {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 45u32,
                                                            __file:
                                                                "hscontrols/input.rs",
                                                            __module_path:
                                                                "horde_survival::hscontrols::input",};
                                    let lvl = $crate::LogLevel::Info;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hscontrols::input",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &["Ability 2: dead"];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match ()
                                                                                         {
                                                                                         ()
                                                                                         =>
                                                                                         [],
                                                                                     }))
                                    }
                                };
                            } else { player.ability_2(entities); }
                        }
                        VirtualKeyCode::Key4 => {
                            if player.dead {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 52u32,
                                                            __file:
                                                                "hscontrols/input.rs",
                                                            __module_path:
                                                                "horde_survival::hscontrols::input",};
                                    let lvl = $crate::LogLevel::Info;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::hscontrols::input",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &["Ability 3: dead"];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match ()
                                                                                         {
                                                                                         ()
                                                                                         =>
                                                                                         [],
                                                                                     }))
                                    }
                                };
                            } else { player.ability_3(entities); }
                        }
                        _ => { }
                    }
                }
                ElementState::Released => {
                    match key {
                        VirtualKeyCode::W => player.input.forward = false,
                        VirtualKeyCode::A => player.input.left = false,
                        VirtualKeyCode::S => player.input.back = false,
                        VirtualKeyCode::D => player.input.right = false,
                        _ => { }
                    }
                }
            }
        }
    }
    pub use self::mouse::*;
    pub use self::movement::*;
    pub use self::input::*;
}
mod gamestate {
    use consts::*;
    use player::*;
    use rand::{Rng, thread_rng};
    use entity::{Entity, EntityType};
    use entity::flags::Team;
    use map::Map;
    use world::Coords;
    use items::weapon::get_random_monster_weapon;
    use hsgraphics::{GraphicsState, get_camera};
    pub struct GameState {
        pub entities: Vec<Entity>,
        pub next_entity_id: usize,
        pub player: Player,
        pub map: Map,
        pub wave: usize,
        pub bounty: usize,
    }
    impl GameState {
        pub fn new() -> GameState {
            let player_entity_id = 0;
            let map =
                Map::new(0.0, Coords::origin(),
                         (TEST_SPAWN_POINTS.0.to_vec(),
                          TEST_SPAWN_POINTS.1.to_vec()));
            let player =
                Player::new(player_entity_id, 0, Class::Warrior,
                            map.player_spawn.clone());
            let player_coords = map.player_spawn.clone();
            GameState{entities:
                          <[_]>::into_vec(box
                                              [Entity::player(player_coords,
                                                              player.entity_id,
                                                              Team::Players)]),
                      next_entity_id: player.entity_id + 1,
                      player: player,
                      map: map,
                      wave: 0,
                      bounty: BASE_BOUNTY,}
        }
        pub fn new_game(&mut self) {
            {
                static _LOC: $crate::LogLocation =
                    $crate::LogLocation{__line: 39u32,
                                        __file: "gamestate.rs",
                                        __module_path:
                                            "horde_survival::gamestate",};
                let lvl = $crate::LogLevel::Info;
                if lvl <= $crate::__static_max_level() &&
                       lvl <= $crate::max_log_level() {
                    $crate::__log(lvl, "horde_survival::gamestate", &_LOC,
                                  ::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["Started new game"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match () {
                                                                     () => [],
                                                                 }))
                }
            };
            *self = GameState::new();
            self.entities[0].armor[0] = balance::items::armor::HEAL;
            self.entities[0].current_weapon =
                balance::items::weapon::TEST_BOW;
        }
    }
    impl GameState {
        pub fn end_round(&mut self, graphics: &mut GraphicsState) {
            let mut player =
                self.entities.iter().find(|e|
                                              e.id ==
                                                  self.player.entity_id).expect("Player entity disappeared").clone();
            player.health = player.max_hp;
            player.coords = self.map.player_spawn.clone();
            graphics.camera =
                get_camera(self.map.player_spawn.clone(),
                           self.player.direction, graphics.aspect_ratio);
            self.player.coords = self.map.player_spawn.clone();
            self.player.current_cooldowns = [0; 4];
            self.entities.clear();
            self.entities.push(player);
            self.player.reset_controls();
        }
        pub fn next_round(&mut self) {
            self.wave += 1;
            self.bounty =
                BASE_BOUNTY + ((BOUNTY_GROWTH * (self.wave as f64)) as usize);
            self.populate();
            {
                static _LOC: $crate::LogLocation =
                    $crate::LogLocation{__line: 68u32,
                                        __file: "gamestate.rs",
                                        __module_path:
                                            "horde_survival::gamestate",};
                let lvl = $crate::LogLevel::Info;
                if lvl <= $crate::__static_max_level() &&
                       lvl <= $crate::max_log_level() {
                    $crate::__log(lvl, "horde_survival::gamestate", &_LOC,
                                  ::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["Starting wave "];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match (&self.wave,)
                                                                     {
                                                                     (__arg0,)
                                                                     =>
                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                  ::std::fmt::Display::fmt)],
                                                                 }))
                }
            };
        }
        pub fn round_finished(&self) -> bool {
            self.entities.iter().find(|e|
                                          e.is_monster() &&
                                              e.team ==
                                                  Team::Monsters).is_none()
        }
    }
    impl GameState {
        pub fn spawn_entity(&mut self, mut entity: Entity) {
            entity.id = self.next_entity_id;
            self.next_entity_id += 1;
            self.entities.push(entity);
        }
        pub fn populate(&mut self) {
            let count = BASE_WAVE_SIZE + (WAVE_SIZE_GROWTH * self.wave);
            let mut rng = thread_rng();
            for _ in 0..count {
                let mut coords = self.map.choose_random_spawn_point();
                coords.translate(&Coords::new((rng.gen::<f64>() - 0.5) *
                                                  MONSTER_SPAWN_RADIUS, 0.0,
                                              (rng.gen::<f64>() - 0.5) *
                                                  MONSTER_SPAWN_RADIUS));
                let mut entity =
                    Entity::monster(EntityType::Zombie, coords, 0,
                                    Team::Monsters, self.bounty);
                let weapon = get_random_monster_weapon(self.wave);
                entity.current_weapon = weapon;
                self.spawn_entity(entity);
            }
        }
    }
}
mod map {
    pub mod mapcollide {
        use world::Coords;
        use map::Map;
        impl Map {
            pub fn test_collision(&self, coords: &Coords, entity_height: f64)
             -> bool {
                coords.y - entity_height <= self.floor_height
            }
            pub fn put_on_ground(&self, coords: &mut Coords,
                                 entity_height: f64) {
                coords.y = self.floor_height + entity_height;
            }
        }
    }
    pub use self::mapcollide::*;
    use random_choice::random_choice;
    use world::Coords;
    pub struct Map {
        pub floor_height: f64,
        pub spawn_points: (Vec<Coords>, Vec<f64>),
        pub player_spawn: Coords,
    }
    impl Map {
        pub fn new(floor_height: f64, player_spawn: Coords,
                   spawn_points: (Vec<Coords>, Vec<f64>)) -> Map {
            Map{floor_height: floor_height,
                spawn_points: spawn_points,
                player_spawn: player_spawn,}
        }
    }
    impl Map {
        pub fn choose_random_spawn_point(&self) -> Coords {
            let (points, weights) =
                (&self.spawn_points.0, &self.spawn_points.1);
            let choice =
                random_choice().random_choice_f64(points, weights, 1);
            choice[0].clone()
        }
    }
}
mod gameloop {
    pub mod player {
        use glutin::Window;
        use gamestate::GameState;
        use hsgraphics::GraphicsState;
        use entity::update_player;
        use hslog::CanUnwrap;
        use hscontrols::center_mouse;
        pub fn update_player_state(game: &mut GameState,
                                   graphics: &mut GraphicsState,
                                   window: &Window) {
            game.player.update_cooldowns();
            let casts;
            {
                let player = &mut game.player;
                let direction = player.direction;
                let player_entity =
                    {
                        {
                            if game.entities.iter_mut().find(|e|
                                                                 e.id ==
                                                                     player.entity_id).can_unwrap()
                               {
                                game.entities.iter_mut().find(|e|
                                                                  e.id ==
                                                                      player.entity_id).unwrap()
                            } else {
                                {
                                    {
                                        static _LOC: $crate::LogLocation =
                                            $crate::LogLocation{__line: 19u32,
                                                                __file:
                                                                    "gameloop/player.rs",
                                                                __module_path:
                                                                    "horde_survival::gameloop::player",};
                                        let lvl = $crate::LogLevel::Error;
                                        if lvl <= $crate::__static_max_level()
                                               &&
                                               lvl <= $crate::max_log_level()
                                           {
                                            $crate::__log(lvl,
                                                          "horde_survival::gameloop::player",
                                                          &_LOC,
                                                          ::std::fmt::Arguments::new_v1({
                                                                                            static __STATIC_FMTSTR:
                                                                                                   &'static [&'static str]
                                                                                                   =
                                                                                                &["Player entity disappeared"];
                                                                                            __STATIC_FMTSTR
                                                                                        },
                                                                                        &match ()
                                                                                             {
                                                                                             ()
                                                                                             =>
                                                                                             [],
                                                                                         }))
                                        }
                                    };
                                    {
                                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                                {
                                                                    static _FILE_LINE:
                                                                           (&'static str,
                                                                            u32)
                                                                           =
                                                                        ("gameloop/player.rs",
                                                                         19u32);
                                                                    &_FILE_LINE
                                                                })
                                    };
                                };
                            }
                        };
                    };
                if player.left_click { player_entity.attack = true; }
                graphics.update_camera(player.coords.clone(), direction);
                casts = update_player(player_entity, player);
            }
            if casts[0] { game.player.ability_0(&mut game.entities); }
            if casts[1] { game.player.ability_1(&mut game.entities); }
            if casts[2] { game.player.ability_2(&mut game.entities); }
            if casts[3] { game.player.ability_3(&mut game.entities); }
            center_mouse(graphics, &mut game.player.mouse, window);
        }
    }
    pub mod event {
        use glutin::{self, Window, Event};
        use gamestate::GameState;
        use hsgraphics::GraphicsState;
        use hscontrols::handle_keyboard_input;
        pub fn handle_event(event: Event, game: &mut GameState,
                            graphics: &mut GraphicsState, window: &Window) {
            match event {
                Event::Resized(..) => {
                    window.set_inner_size(graphics.window_size.0,
                                          graphics.window_size.1);
                }
                Event::MouseMoved(x, y) => {
                    graphics.last_cursor_pos = (x, y);
                }
                Event::KeyboardInput(state, scan_code, key) => {
                    let player = &mut game.player;
                    handle_keyboard_input(key, state, scan_code,
                                          &mut game.entities, player);
                }
                Event::MouseInput(state, button) => {
                    if let glutin::MouseButton::Left = button {
                        game.player.left_click =
                            state == glutin::ElementState::Pressed;
                    }
                }
                Event::Closed => graphics.should_close = true,
                _ => { }
            }
        }
    }
    pub mod game {
        use glutin::*;
        use consts::misc::TPS;
        use entity::*;
        use gameloop::{self, LoopType};
        use gamestate::GameState;
        use hsgraphics::GraphicsState;
        use utils::*;
        use tps::{Ticks, tps_to_time};
        use gui::{UI, UIState};
        pub fn gametick(event: Option<Event>, ui: &mut UI,
                        game: &mut GameState, graphics: &mut GraphicsState,
                        window: &Window, ticks: &mut Ticks,
                        loop_type: &mut LoopType) {
            ticks.begin_tick();
            let expected_elapsed = tps_to_time(TPS);
            ticks.set_expected_elapsed(expected_elapsed);
            if let Some(e) = event {
                if let Event::KeyboardInput(ElementState::Pressed, _,
                                            Some(VirtualKeyCode::Escape)) = e
                       {
                    *loop_type = LoopType::GUI;
                    ui.state = UIState::Pause;
                    set_cursor_state(window, CursorState::Normal);
                    game.player.reset_controls();
                    return;
                }
                gameloop::handle_event(e, game, graphics, window);
            }
            graphics.draw(window);
            ticks.measure_frame_1();
            if ticks.is_sleeping() { return; }
            gameloop::update_player_state(game, graphics, window);
            for i in 0..game.entities.len() {
                update_entity(&mut game.entities, i, &game.map,
                              &mut game.player, &mut game.next_entity_id);
            }
            filter_entities(&mut game.entities);
            if game.round_finished() {
                *loop_type = LoopType::GUI;
                *ticks = Ticks::new();
                ui.state = UIState::Shop;
                game.end_round(graphics);
                set_cursor_state(window, CursorState::Normal);
            }
            ticks.measure_update();
            graphics.update(game);
            ticks.measure_frame_2();
            ticks.end_tick();
            if graphics.options.display_debug {
                let info = ticks.get_debug_info();
                let frame = millis(info[0]);
                let update = millis(info[1]);
                let total = millis(info[2]);
                let string =
                    $crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                          static __STATIC_FMTSTR:
                                                                                 &'static [&'static str]
                                                                                 =
                                                                              &["Horde Survival - frame ",
                                                                                " ms | updates ",
                                                                                " ms | total ",
                                                                                " ms"];
                                                                          __STATIC_FMTSTR
                                                                      },
                                                                      &match (&frame,
                                                                              &update,
                                                                              &total)
                                                                           {
                                                                           (__arg0,
                                                                            __arg1,
                                                                            __arg2)
                                                                           =>
                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                        ::std::fmt::Display::fmt),
                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                        ::std::fmt::Display::fmt),
                                                                            ::std::fmt::ArgumentV1::new(__arg2,
                                                                                                        ::std::fmt::Display::fmt)],
                                                                       }));
                window.set_title(&string);
            }
        }
    }
    pub mod loading {
        use glutin::Window;
        use consts::graphics::*;
        use hsgraphics::{GraphicsState, shapes3d};
        use hsgraphics::object3d::Object3d;
        use gameloop::LoopType;
        use hslog::CanUnwrap;
        use gui::UI;
        pub fn loading_screen(ui: &mut UI, graphics: &mut GraphicsState,
                              window: &Window, loop_type: &mut LoopType) {
            let name = "loading_screen";
            graphics.assets.add_texture_assets(&[(name,
                                                  "test_assets/loading_screen.png")]);
            if let Err(e) =
                   graphics.assets.load_texture(name, &mut graphics.factory) {
                {
                    {
                        static _LOC: $crate::LogLocation =
                            $crate::LogLocation{__line: 19u32,
                                                __file: "gameloop/loading.rs",
                                                __module_path:
                                                    "horde_survival::gameloop::loading",};
                        let lvl = $crate::LogLevel::Error;
                        if lvl <= $crate::__static_max_level() &&
                               lvl <= $crate::max_log_level() {
                            $crate::__log(lvl,
                                          "horde_survival::gameloop::loading",
                                          &_LOC,
                                          ::std::fmt::Arguments::new_v1({
                                                                            static __STATIC_FMTSTR:
                                                                                   &'static [&'static str]
                                                                                   =
                                                                                &[""];
                                                                            __STATIC_FMTSTR
                                                                        },
                                                                        &match (&$crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                                                                       static __STATIC_FMTSTR:
                                                                                                                                              &'static [&'static str]
                                                                                                                                              =
                                                                                                                                           &["Failed to load texture ",
                                                                                                                                             ": "];
                                                                                                                                       __STATIC_FMTSTR
                                                                                                                                   },
                                                                                                                                   &match (&name,
                                                                                                                                           &e)
                                                                                                                                        {
                                                                                                                                        (__arg0,
                                                                                                                                         __arg1)
                                                                                                                                        =>
                                                                                                                                        [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                                                     ::std::fmt::Display::fmt),
                                                                                                                                         ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                                                     ::std::fmt::Display::fmt)],
                                                                                                                                    })),)
                                                                             {
                                                                             (__arg0,)
                                                                             =>
                                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                          ::std::fmt::Display::fmt)],
                                                                         }))
                        }
                    };
                    {
                        $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("gameloop/loading.rs",
                                                         19u32);
                                                    &_FILE_LINE
                                                })
                    };
                };
            }
            graphics.encoder.clear(&graphics.data.out_color,
                                   LOADING_CLEAR_COLOR);
            graphics.draw_gui(window);
            let names =
                [("floor", "test_assets/floor.png"),
                 ("pepe", "test_assets/pepe.png"),
                 ("player", "test_assets/player.png"),
                 ("zombie", "test_assets/zombie.png"),
                 ("crosshair", "test_assets/crosshair.png"),
                 ("ball_linear", "test_assets/ball_linear.png"),
                 ("ball_arc", "test_assets/ball_arc.png")];
            graphics.assets.add_texture_assets(&names);
            for &(name, path) in &names {
                {
                    static _LOC: $crate::LogLocation =
                        $crate::LogLocation{__line: 41u32,
                                            __file: "gameloop/loading.rs",
                                            __module_path:
                                                "horde_survival::gameloop::loading",};
                    let lvl = $crate::LogLevel::Info;
                    if lvl <= $crate::__static_max_level() &&
                           lvl <= $crate::max_log_level() {
                        $crate::__log(lvl,
                                      "horde_survival::gameloop::loading",
                                      &_LOC,
                                      ::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["Loading texture \'",
                                                                              "\' (",
                                                                              ")"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match (&name,
                                                                            &path)
                                                                         {
                                                                         (__arg0,
                                                                          __arg1)
                                                                         =>
                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                      ::std::fmt::Display::fmt),
                                                                          ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                      ::std::fmt::Display::fmt)],
                                                                     }))
                    }
                };
                if let Err(e) =
                       graphics.assets.load_texture(name,
                                                    &mut graphics.factory) {
                    {
                        {
                            static _LOC: $crate::LogLocation =
                                $crate::LogLocation{__line: 43u32,
                                                    __file:
                                                        "gameloop/loading.rs",
                                                    __module_path:
                                                        "horde_survival::gameloop::loading",};
                            let lvl = $crate::LogLevel::Error;
                            if lvl <= $crate::__static_max_level() &&
                                   lvl <= $crate::max_log_level() {
                                $crate::__log(lvl,
                                              "horde_survival::gameloop::loading",
                                              &_LOC,
                                              ::std::fmt::Arguments::new_v1({
                                                                                static __STATIC_FMTSTR:
                                                                                       &'static [&'static str]
                                                                                       =
                                                                                    &[""];
                                                                                __STATIC_FMTSTR
                                                                            },
                                                                            &match (&$crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                                                                           static __STATIC_FMTSTR:
                                                                                                                                                  &'static [&'static str]
                                                                                                                                                  =
                                                                                                                                               &["Failed to load texture ",
                                                                                                                                                 ": "];
                                                                                                                                           __STATIC_FMTSTR
                                                                                                                                       },
                                                                                                                                       &match (&name,
                                                                                                                                               &e)
                                                                                                                                            {
                                                                                                                                            (__arg0,
                                                                                                                                             __arg1)
                                                                                                                                            =>
                                                                                                                                            [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                                                         ::std::fmt::Display::fmt),
                                                                                                                                             ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                                                         ::std::fmt::Display::fmt)],
                                                                                                                                        })),)
                                                                                 {
                                                                                 (__arg0,)
                                                                                 =>
                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                              ::std::fmt::Display::fmt)],
                                                                             }))
                            }
                        };
                        {
                            $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("gameloop/loading.rs",
                                                             43u32);
                                                        &_FILE_LINE
                                                    })
                        };
                    };
                }
            }
            ui.image_map =
                {
                    let mut map = $crate::image::Map::new();
                    map.insert(ui.ids.main_menu_image,
                               graphics.assets.get_texture("pepe").unwrap().clone());
                    map
                };
            let texture =
                {
                    {
                        if graphics.assets.get_or_load_texture("floor",
                                                               &mut graphics.factory).can_unwrap()
                           {
                            graphics.assets.get_or_load_texture("floor",
                                                                &mut graphics.factory).unwrap()
                        } else {
                            {
                                {
                                    static _LOC: $crate::LogLocation =
                                        $crate::LogLocation{__line: 52u32,
                                                            __file:
                                                                "gameloop/loading.rs",
                                                            __module_path:
                                                                "horde_survival::gameloop::loading",};
                                    let lvl = $crate::LogLevel::Error;
                                    if lvl <= $crate::__static_max_level() &&
                                           lvl <= $crate::max_log_level() {
                                        $crate::__log(lvl,
                                                      "horde_survival::gameloop::loading",
                                                      &_LOC,
                                                      ::std::fmt::Arguments::new_v1({
                                                                                        static __STATIC_FMTSTR:
                                                                                               &'static [&'static str]
                                                                                               =
                                                                                            &["Failed to find texture: floor"];
                                                                                        __STATIC_FMTSTR
                                                                                    },
                                                                                    &match ()
                                                                                         {
                                                                                         ()
                                                                                         =>
                                                                                         [],
                                                                                     }))
                                    }
                                };
                                {
                                    $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("gameloop/loading.rs",
                                                                     52u32);
                                                                &_FILE_LINE
                                                            })
                                };
                            };
                        }
                    };
                }.clone();
            let (v, i) = shapes3d::plane(FLOOR_HEIGHT, 1000.0);
            let floor_object =
                Object3d::from_slice(&mut graphics.factory, &v, &i, texture);
            graphics.add_object3d(floor_object, 0);
            *loop_type = LoopType::GUI;
        }
    }
    pub mod ui {
        use glutin::*;
        use conrod;
        use gamestate::GameState;
        use hsgraphics::GraphicsState;
        use gameloop::LoopType;
        use gui::{UI, UIState, draw};
        use tps::{Ticks, tps_to_time};
        use consts::misc::GUI_MAX_FPS;
        use consts::graphics::GUI_CLEAR_COLOR;
        use utils::*;
        pub fn run_gui(event: Option<Event>, ui: &mut UI,
                       game: &mut GameState, graphics: &mut GraphicsState,
                       window: &Window, ticks: &mut Ticks,
                       loop_type: &mut LoopType) {
            ticks.begin_tick();
            let expected_elapsed = tps_to_time(GUI_MAX_FPS);
            ticks.set_expected_elapsed(expected_elapsed);
            let (w, h) =
                match window.get_inner_size() {
                    Some(s) => s,
                    None => { graphics.should_close = true; return; }
                };
            graphics.update_dpi(window);
            let dt_secs = 0.0;
            ui.ui.handle_event(conrod::event::render(dt_secs, w, h,
                                                     graphics.dpi as
                                                         conrod::Scalar));
            if let Some(e) = event {
                let (w, h) = (w as conrod::Scalar, h as conrod::Scalar);
                let dpi = graphics.dpi as conrod::Scalar;
                if let Some(event) =
                       conrod::backend::glutin::convert(e.clone(), w, h, dpi)
                       {
                    ui.ui.handle_event(event);
                }
                match e {
                    Event::Resized(..) => {
                        window.set_inner_size(graphics.window_size.0,
                                              graphics.window_size.1);
                    }
                    Event::MouseMoved(x, y) => {
                        graphics.last_cursor_pos = (x, y);
                    }
                    Event::KeyboardInput(ElementState::Pressed, _,
                                         Some(VirtualKeyCode::Escape)) => {
                        match ui.state {
                            UIState::Pause => {
                                *loop_type = LoopType::Game;
                                set_cursor_state(window, CursorState::Hide);
                                graphics.reset_cursor(window);
                            }
                            UIState::Options => { ui.state = UIState::Main; }
                            UIState::Main => { graphics.should_close = true; }
                            _ => { }
                        }
                    }
                    Event::Closed => graphics.should_close = true,
                    _ => { }
                }
            }
            if ticks.is_sleeping() { return; }
            if let Some(primitives) = ui.ui.draw_if_changed() {
                graphics.encoder.clear(&graphics.data.out_color,
                                       GUI_CLEAR_COLOR);
                draw::draw_primitives(primitives, (w, h), graphics,
                                      &ui.image_map);
                graphics.draw_gui(window);
            }
            ui.set_widgets(game, graphics, loop_type, window);
            ticks.measure_frame_1();
            if graphics.options.display_debug {
                let frame = millis(ticks.get_debug_info()[0]);
                let string =
                    $crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                          static __STATIC_FMTSTR:
                                                                                 &'static [&'static str]
                                                                                 =
                                                                              &["Horde Survival - frame ",
                                                                                " ms | updates 0 ms | total ",
                                                                                " ms"];
                                                                          __STATIC_FMTSTR
                                                                      },
                                                                      &match (&frame,
                                                                              &frame)
                                                                           {
                                                                           (__arg0,
                                                                            __arg1)
                                                                           =>
                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                        ::std::fmt::Display::fmt),
                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                        ::std::fmt::Display::fmt)],
                                                                       }));
                window.set_title(&string);
            }
            ticks.end_tick();
        }
    }
    pub use self::event::handle_event;
    pub use self::player::update_player_state;
    pub use self::game::gametick;
    pub use self::ui::run_gui;
    pub use self::loading::loading_screen;
    pub enum LoopType { Game, GUI, Loading, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LoopType {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&LoopType::Game,) => {
                    let mut builder = __arg_0.debug_tuple("Game");
                    builder.finish()
                }
                (&LoopType::GUI,) => {
                    let mut builder = __arg_0.debug_tuple("GUI");
                    builder.finish()
                }
                (&LoopType::Loading,) => {
                    let mut builder = __arg_0.debug_tuple("Loading");
                    builder.finish()
                }
            }
        }
    }
}
mod gui {
    pub mod ids {
        pub struct Ids {
            pub background: $crate::widget::Id,
            pub button_new_game: $crate::widget::Id,
            pub button_options: $crate::widget::Id,
            pub button_quit: $crate::widget::Id,
            pub main_menu_image: $crate::widget::Id,
        }
        impl Ids {
            /// Construct a new `widget::Id` container.
            #[allow(unused_mut, unused_variables)]
            pub fn new(mut generator: $crate::widget::id::Generator) -> Self {
                Ids{background: generator.next(),
                    button_new_game: generator.next(),
                    button_options: generator.next(),
                    button_quit: generator.next(),
                    main_menu_image: generator.next(),}
            }
        }
    }
    pub mod draw {
        use conrod::{self, render};
        use conrod::render::{Text, PrimitiveKind};
        use conrod::text::{font, rt};
        use hsgraphics::GraphicsState;
        use hsgraphics::gfx2d::Vertex;
        use hsgraphics::gfx_gui::{GUIObject, Vertex as GVertex};
        use hsgraphics::texture::{Texture, update_cache_texture};
        use hsgraphics::object2d::Object2d;
        use hslog::CanUnwrap;
        use gui::utils::*;
        #[allow(unused_variables)]
        pub fn draw_primitives<'a>(mut primitives: render::Primitives<'a>,
                                   (w, h): (u32, u32),
                                   graphics: &mut GraphicsState,
                                   image_map: &conrod::image::Map<Texture>) {
            let (screen_width, screen_height) =
                ((w as f32) * graphics.dpi, (h as f32) * graphics.dpi);
            let origin = rt::point(0.0, 0.0);
            while let Some(render::Primitive { id, kind, scizzor, rect }) =
                      primitives.next() {
                match kind {
                    PrimitiveKind::Text { color, text, font_id } => {
                        primitive_text(text, color, font_id, &origin,
                                       (screen_width, screen_height),
                                       graphics);
                    }
                    PrimitiveKind::Rectangle { color } => {
                        primitive_rectangle(color, rect,
                                            (screen_width, screen_height),
                                            graphics);
                    }
                    PrimitiveKind::Image { color, source_rect } => {
                        primitive_image(id, color, rect, source_rect,
                                        (screen_width, screen_height),
                                        graphics, image_map)
                    }
                    _ => {
                        let kind_text =
                            match kind {
                                PrimitiveKind::Rectangle { .. } =>
                                "Rectangle",
                                PrimitiveKind::Polygon { .. } => "Polygon",
                                PrimitiveKind::Lines { .. } => "Lines",
                                PrimitiveKind::Image { .. } => "Image",
                                PrimitiveKind::Text { .. } => "Text",
                                PrimitiveKind::Other(_) => continue ,
                            };
                        {
                            static _LOC: $crate::LogLocation =
                                $crate::LogLocation{__line: 53u32,
                                                    __file: "gui/draw.rs",
                                                    __module_path:
                                                        "horde_survival::gui::draw",};
                            let lvl = $crate::LogLevel::Warn;
                            if lvl <= $crate::__static_max_level() &&
                                   lvl <= $crate::max_log_level() {
                                $crate::__log(lvl,
                                              "horde_survival::gui::draw",
                                              &_LOC,
                                              ::std::fmt::Arguments::new_v1({
                                                                                static __STATIC_FMTSTR:
                                                                                       &'static [&'static str]
                                                                                       =
                                                                                    &["Drawing unknown primitive: "];
                                                                                __STATIC_FMTSTR
                                                                            },
                                                                            &match (&kind_text,)
                                                                                 {
                                                                                 (__arg0,)
                                                                                 =>
                                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                              ::std::fmt::Debug::fmt)],
                                                                             }))
                            }
                        };
                    }
                }
            }
        }
        fn primitive_text(text: Text, color: conrod::Color, font_id: font::Id,
                          origin: &rt::Point<f32>, screen_size: (f32, f32),
                          graphics: &mut GraphicsState) {
            let positioned_glyphs = text.positioned_glyphs(graphics.dpi);
            for glyph in positioned_glyphs {
                graphics.cache.cache.queue_glyph(font_id.index(),
                                                 glyph.clone());
            }
            let encoder = &mut graphics.encoder;
            let cache = &mut graphics.cache.cache;
            let cache_tex = &graphics.cache.texture;
            cache.cache_queued(|rect, data| {
                               let offset =
                                   [rect.min.x as u16, rect.min.y as u16];
                               let size =
                                   [rect.width() as u16,
                                    rect.height() as u16];
                               let new_data =
                                   data.iter().map(|x|
                                                       [0, 0, 0,
                                                        *x]).collect::<Vec<_>>();
                               update_cache_texture(encoder, cache_tex,
                                                    offset, size, &new_data);
                           }).unwrap();
            let color = color.to_fsa();
            let cache_id = font_id.index();
            let to_gl_rect =
                |screen_rect: rt::Rect<i32>|
                    rt::Rect{min:
                                 rt_to_gl_pos(screen_rect.min, origin,
                                              screen_size),
                             max:
                                 rt_to_gl_pos(screen_rect.max, origin,
                                              screen_size),};
            let vertices: Vec<_> =
                positioned_glyphs.into_iter().filter_map(|g|
                                                             cache.rect_for(cache_id,
                                                                            g).ok().unwrap_or(None)).flat_map(|(uv_rect,
                                                                                                                screen_rect)|
                                                                                                                  {
                                                                                                              use std::iter::once;
                                                                                                              let gl_rect =
                                                                                                                  to_gl_rect(screen_rect);
                                                                                                              let v =
                                                                                                                  |pos,
                                                                                                                   uv|
                                                                                                                      once(vertex(pos,
                                                                                                                                  uv,
                                                                                                                                  color));
                                                                                                              v([gl_rect.min.x,
                                                                                                                 gl_rect.max.y],
                                                                                                                [uv_rect.min.x,
                                                                                                                 uv_rect.max.y]).chain(v([gl_rect.min.x,
                                                                                                                                          gl_rect.min.y],
                                                                                                                                         [uv_rect.min.x,
                                                                                                                                          uv_rect.min.y])).chain(v([gl_rect.max.x,
                                                                                                                                                                    gl_rect.min.y],
                                                                                                                                                                   [uv_rect.max.x,
                                                                                                                                                                    uv_rect.min.y])).chain(v([gl_rect.max.x,
                                                                                                                                                                                              gl_rect.min.y],
                                                                                                                                                                                             [uv_rect.max.x,
                                                                                                                                                                                              uv_rect.min.y])).chain(v([gl_rect.max.x,
                                                                                                                                                                                                                        gl_rect.max.y],
                                                                                                                                                                                                                       [uv_rect.max.x,
                                                                                                                                                                                                                        uv_rect.max.y])).chain(v([gl_rect.min.x,
                                                                                                                                                                                                                                                  gl_rect.max.y],
                                                                                                                                                                                                                                                 [uv_rect.min.x,
                                                                                                                                                                                                                                                  uv_rect.max.y]))
                                                                                                          }).collect();
            let text =
                Object2d::from_slice(&mut graphics.factory, &vertices,
                                     graphics.cache.texture_view.clone());
            text.encode(encoder, &graphics.pso2d, &mut graphics.data2d);
        }
        fn primitive_rectangle(color: conrod::Color, rect: conrod::Rect,
                               screen_size: (f32, f32),
                               graphics: &mut GraphicsState) {
            let color = color.to_fsa();
            let v =
                |p: conrod::Point|
                    GVertex::new([p[0] as f32, p[1] as f32], color);
            let rect = conrod_to_gl_rect(rect, screen_size);
            let vertices =
                [v(rect.bottom_left()), v(rect.top_left()),
                 v(rect.top_right()), v(rect.bottom_right())];
            let indices = [0, 1, 2, 0, 3, 2];
            let rectangle =
                GUIObject::new(&mut graphics.factory, &vertices, &indices);
            rectangle.encode(&mut graphics.encoder, &graphics.pso_gui,
                             &mut graphics.data_gui);
        }
        fn primitive_image(id: conrod::widget::Id,
                           color: Option<conrod::Color>, rect: conrod::Rect,
                           uv_rect: Option<conrod::Rect>,
                           screen_size: (f32, f32),
                           graphics: &mut GraphicsState,
                           image_map: &conrod::image::Map<Texture>) {
            let uv_rect =
                uv_rect.unwrap_or_else(||
                                           conrod::Rect::from_xy_dim([0.5; 2],
                                                                     [1.0;
                                                                         2]));
            let color =
                color.unwrap_or(conrod::Color::Rgba(0.0, 0.0, 0.0,
                                                    1.0)).to_fsa();
            let v = |p: conrod::Point, uv: conrod::Point| {
                Vertex::new_colored([p[0] as f32, p[1] as f32],
                                    [uv[0] as f32, uv[1] as f32], color) };
            let rect = conrod_to_gl_rect(rect, screen_size);
            let vertices =
                [v(rect.bottom_left(), uv_rect.top_left()),
                 v(rect.top_left(), uv_rect.bottom_left()),
                 v(rect.top_right(), uv_rect.bottom_right()),
                 v(rect.bottom_right(), uv_rect.top_right())];
            let indices = [0, 1, 2, 0, 3, 2];
            let texture =
                {
                    if image_map.get(&id).can_unwrap() {
                        image_map.get(&id).unwrap()
                    } else {
                        {
                            {
                                static _LOC: $crate::LogLocation =
                                    $crate::LogLocation{__line: 158u32,
                                                        __file: "gui/draw.rs",
                                                        __module_path:
                                                            "horde_survival::gui::draw",};
                                let lvl = $crate::LogLevel::Error;
                                if lvl <= $crate::__static_max_level() &&
                                       lvl <= $crate::max_log_level() {
                                    $crate::__log(lvl,
                                                  "horde_survival::gui::draw",
                                                  &_LOC,
                                                  ::std::fmt::Arguments::new_v1({
                                                                                    static __STATIC_FMTSTR:
                                                                                           &'static [&'static str]
                                                                                           =
                                                                                        &["Failed to get texture with ID ",
                                                                                          " from image_map"];
                                                                                    __STATIC_FMTSTR
                                                                                },
                                                                                &match (&id.index(),)
                                                                                     {
                                                                                     (__arg0,)
                                                                                     =>
                                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                  ::std::fmt::Display::fmt)],
                                                                                 }))
                                }
                            };
                            {
                                $crate::rt::begin_panic($crate::consts::misc::CRASH_MESSAGE,
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("gui/draw.rs",
                                                                 158u32);
                                                            &_FILE_LINE
                                                        })
                            };
                        };
                    }
                };
            let object =
                Object2d::from_slice_indices(&mut graphics.factory, &vertices,
                                             &indices, texture.clone());
            object.encode(&mut graphics.encoder, &graphics.pso2d,
                          &mut graphics.data2d);
        }
    }
    pub mod menus {
        pub mod loading { }
        pub mod main {
            use glutin::{Window, CursorState};
            use conrod::{self, Widget, Colorable, Positionable, Sizeable,
                         Labelable, widget, color};
            use gui::ids::Ids;
            use gui::UIState;
            use gamestate::GameState;
            use hsgraphics::GraphicsState;
            use gameloop::LoopType;
            use utils::set_cursor_state;
            pub fn set_widgets(ui: &mut conrod::UiCell, ids: &Ids,
                               game: &mut GameState,
                               graphics: &mut GraphicsState,
                               ui_state: &mut UIState,
                               loop_type: &mut LoopType, window: &Window) {
                let bg_color = ui.theme.background_color;
                widget::Canvas::new().color(bg_color).set(ids.background, ui);
                if widget::Button::new().label("New game").label_font_size(30).label_color(color::BLUE).w_h(225.0,
                                                                                                            50.0).color(color::TRANSPARENT).up_from(ids.button_options,
                                                                                                                                                    0.0).depth(-2.0).set(ids.button_new_game,
                                                                                                                                                                         ui).was_clicked()
                   {
                    game.new_game();
                    game.next_round();
                    set_cursor_state(window, CursorState::Hide);
                    graphics.reset_cursor(window);
                    *loop_type = LoopType::Game;
                }
                if widget::Button::new().label("Options").label_font_size(30).label_color(color::BLUE).w_h(225.0,
                                                                                                           50.0).color(color::TRANSPARENT).up_from(ids.button_quit,
                                                                                                                                                   0.0).depth(-2.0).set(ids.button_options,
                                                                                                                                                                        ui).was_clicked()
                   {
                    *ui_state = UIState::Options;
                }
                if widget::Button::new().label("Quit").label_font_size(30).label_color(color::BLUE).w_h(225.0,
                                                                                                        50.0).color(color::TRANSPARENT).bottom_left_of(ids.background).depth(-2.0).set(ids.button_quit,
                                                                                                                                                                                       ui).was_clicked()
                   {
                    graphics.should_close = true;
                }
                widget::Image::new().wh_of(ids.background).middle().depth(-1.0).set(ids.main_menu_image,
                                                                                    ui);
            }
        }
        pub mod options { }
        pub mod shop { }
        pub mod ingame { }
        pub mod pause { }
        pub mod game_over { }
        pub mod new_game { }
    }
    mod utils {
        use conrod::text::rt;
        use conrod::{Rect, Range};
        use hsgraphics::gfx2d::Vertex;
        pub fn rt_to_gl_pos(rt_pos: rt::Point<i32>, origin: &rt::Point<f32>,
                            (screen_width, screen_height): (f32, f32))
         -> rt::Point<f32> {
            *origin +
                rt::vector((rt_pos.x as f32) / screen_width - 0.5,
                           1.0 - (rt_pos.y as f32) / screen_height - 0.5) *
                    2.0
        }
        pub fn conrod_to_gl_rect(rect: Rect,
                                 (screen_width, screen_height): (f32, f32))
         -> Rect {
            let (screen_width, screen_height) =
                (screen_width as f64, screen_height as f64);
            let sx = |x| x * 2.0 / screen_width;
            let sy = |y| y * 2.0 / screen_height;
            Rect{x: Range::new(sx(rect.x.start), sx(rect.x.end)),
                 y: Range::new(sy(rect.y.start), sy(rect.y.end)),}
        }
        pub fn vertex(pos: [f32; 2], uv: [f32; 2], color: [f32; 4])
         -> Vertex {
            Vertex::new_colored(pos, uv, color)
        }
    }
    use conrod::{self, Ui, UiBuilder, Theme, color};
    use glutin::Window;
    use hsgraphics::GraphicsState;
    use hsgraphics::texture::Texture;
    use gamestate::GameState;
    use gameloop::LoopType;
    pub struct UI {
        pub ui: Ui,
        pub ids: ids::Ids,
        pub state: UIState,
        pub image_map: conrod::image::Map<Texture>,
    }
    #[structural_match]
    pub enum UIState { Main, Pause, Options, Shop, NewGame, GameOver, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for UIState {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&UIState::Main,) => {
                    let mut builder = __arg_0.debug_tuple("Main");
                    builder.finish()
                }
                (&UIState::Pause,) => {
                    let mut builder = __arg_0.debug_tuple("Pause");
                    builder.finish()
                }
                (&UIState::Options,) => {
                    let mut builder = __arg_0.debug_tuple("Options");
                    builder.finish()
                }
                (&UIState::Shop,) => {
                    let mut builder = __arg_0.debug_tuple("Shop");
                    builder.finish()
                }
                (&UIState::NewGame,) => {
                    let mut builder = __arg_0.debug_tuple("NewGame");
                    builder.finish()
                }
                (&UIState::GameOver,) => {
                    let mut builder = __arg_0.debug_tuple("GameOver");
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for UIState {
        #[inline]
        fn clone(&self) -> UIState {
            match (&*self,) {
                (&UIState::Main,) => UIState::Main,
                (&UIState::Pause,) => UIState::Pause,
                (&UIState::Options,) => UIState::Options,
                (&UIState::Shop,) => UIState::Shop,
                (&UIState::NewGame,) => UIState::NewGame,
                (&UIState::GameOver,) => UIState::GameOver,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for UIState {
        #[inline]
        fn eq(&self, __arg_0: &UIState) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for UIState {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    impl UI {
        pub fn new() -> UI {
            let theme =
                Theme{background_color: color::BLUE,
                      border_color: color::TRANSPARENT, ..Theme::default()};
            let mut ui = UiBuilder::new().theme(theme).build();
            let ids = ids::Ids::new(ui.widget_id_generator());
            ui.fonts.insert_from_file("test_assets/Arial Unicode.ttf").unwrap();
            UI{ui: ui,
               ids: ids,
               state: UIState::Main,
               image_map: conrod::image::Map::new(),}
        }
        pub fn set_widgets(&mut self, game: &mut GameState,
                           graphics: &mut GraphicsState,
                           loop_type: &mut LoopType, window: &Window) {
            let cell = &mut self.ui.set_widgets();
            let ids = &self.ids;
            let ui_state = &mut self.state;
            match self.state {
                UIState::Main =>
                menus::main::set_widgets(cell, ids, game, graphics, ui_state,
                                         loop_type, window),
                UIState::Pause => return,
                _ => { }
            }
        }
    }
}
mod tps {
    use consts::misc::TPS;
    use std::time::{Instant, Duration};
    pub struct Ticks {
        pub expected_elapsed: Duration,
        sleeping_until: Instant,
        time_0: Instant,
        time_1: Instant,
        time_2: Instant,
        frame_time: Duration,
        update_time: Duration,
    }
    impl Ticks {
        pub fn new() -> Ticks {
            let now = Instant::now();
            let zero = Duration::from_millis(0);
            Ticks{expected_elapsed:
                      Duration::from_millis(1000000000 / TPS / 1000000),
                  sleeping_until: now,
                  time_0: now,
                  time_1: now,
                  time_2: now,
                  frame_time: zero,
                  update_time: zero,}
        }
        pub fn set_expected_elapsed(&mut self, duration: Duration) {
            self.expected_elapsed = duration;
        }
        pub fn begin_tick(&mut self) { self.time_0 = Instant::now(); }
        pub fn measure_frame_1(&mut self) {
            self.time_1 = Instant::now();
            self.frame_time = self.time_1 - self.time_0;
        }
        pub fn measure_frame_2(&mut self) {
            self.frame_time += Instant::now() - self.time_2;
        }
        pub fn measure_update(&mut self) {
            self.time_2 = Instant::now();
            self.update_time = self.time_2 - self.time_1;
        }
        pub fn is_sleeping(&self) -> bool {
            Instant::now() < self.sleeping_until
        }
        pub fn get_debug_info(&self) -> [Duration; 3] {
            [self.frame_time, self.update_time,
             self.frame_time + self.update_time]
        }
        pub fn end_tick(&mut self) {
            let current = Instant::now();
            let elapsed = current - self.time_0;
            if elapsed < self.expected_elapsed {
                self.sleeping_until =
                    current + (self.expected_elapsed - elapsed);
            }
        }
    }
    pub fn tps_to_time(tps: u64) -> Duration {
        Duration::from_millis(1000 / tps)
    }
}
mod assets {
    pub mod load {
        use gfx_device_gl::Factory;
        use hsgraphics::texture::*;
        use std::io::{self, Read};
        use std::fs::File;
        use std::path::Path;
        pub fn load_bytes<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {
            let mut file =
                match File::open(path) {
                    $crate::result::Result::Ok(val) => val,
                    $crate::result::Result::Err(err) => {
                        return $crate::result::Result::Err($crate::convert::From::from(err))
                    }
                };
            let mut buf = Vec::new();
            match file.read_to_end(&mut buf) {
                $crate::result::Result::Ok(val) => val,
                $crate::result::Result::Err(err) => {
                    return $crate::result::Result::Err($crate::convert::From::from(err))
                }
            };
            Ok(buf)
        }
        pub trait LoadAsset: Sized {
            fn load_asset<P: AsRef<Path>>(&mut Factory, P)
            -> io::Result<Self>;
        }
        impl LoadAsset for Texture {
            fn load_asset<P: AsRef<Path>>(factory: &mut Factory, path: P)
             -> io::Result<Self> {
                let bytes =
                    match load_bytes(path) {
                        $crate::result::Result::Ok(val) => val,
                        $crate::result::Result::Err(err) => {
                            return $crate::result::Result::Err($crate::convert::From::from(err))
                        }
                    };
                Ok(load_texture(factory, &bytes))
            }
        }
    }
    pub mod single {
        use gfx_device_gl::Factory;
        use assets::LoadAsset;
        use std::path::Path;
        use std::io;
        pub struct Asset<T: LoadAsset, P: AsRef<Path>> {
            path: P,
            data: AssetData<T>,
        }
        pub enum AssetData<T: LoadAsset> { Loaded(T), Unloaded, }
        impl <T: LoadAsset, P: AsRef<Path>> Asset<T, P> {
            pub fn new(path: P) -> Self {
                Asset{path: path, data: AssetData::Unloaded,}
            }
            pub fn get(&self) -> Option<&T> {
                match self.data {
                    AssetData::Loaded(ref a) => Some(a),
                    AssetData::Unloaded => None,
                }
            }
            pub fn get_or_load(&mut self, factory: &mut Factory)
             -> io::Result<&T> {
                match self.data {
                    AssetData::Loaded(ref a) => Ok(a),
                    AssetData::Unloaded => {
                        match self.load(factory) {
                            $crate::result::Result::Ok(val) => val,
                            $crate::result::Result::Err(err) => {
                                return $crate::result::Result::Err($crate::convert::From::from(err))
                            }
                        };
                        Ok(self.get().unwrap())
                    }
                }
            }
            pub fn load(&mut self, factory: &mut Factory) -> io::Result<()> {
                let asset =
                    match T::load_asset(factory, &self.path) {
                        $crate::result::Result::Ok(val) => val,
                        $crate::result::Result::Err(err) => {
                            return $crate::result::Result::Err($crate::convert::From::from(err))
                        }
                    };
                self.data = AssetData::Loaded(asset);
                Ok(())
            }
        }
    }
    #[macro_use]
    mod utils { }
    pub use self::load::*;
    pub use self::single::*;
    use gfx_device_gl::Factory;
    use hsgraphics::texture::Texture;
    use std::path::Path;
    use std::collections::HashMap;
    use std::io::{self, Error, ErrorKind};
    pub struct AssetLoader<P: AsRef<Path>> {
        textures: HashMap<&'static str, Asset<Texture, P>>,
    }
    impl <P: AsRef<Path>> AssetLoader<P> {
        pub fn new() -> Self { AssetLoader{textures: HashMap::new(),} }
    }
    impl <P: AsRef<Path>> AssetLoader<P> {
        pub fn get_texture(&self, name: &str) -> Option<&Texture> {
            self.textures.get(name).map(|a| a.get()).unwrap_or(None)
        }
        pub fn load_texture(&mut self, name: &str, factory: &mut Factory)
         -> io::Result<()> {
            match self.textures.get_mut(name) {
                Some(asset) => asset.load(factory),
                None =>
                Err(Error::new(ErrorKind::Other,
                               $crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                     static __STATIC_FMTSTR:
                                                                                            &'static [&'static str]
                                                                                            =
                                                                                         &["",
                                                                                           " asset not found: "];
                                                                                     __STATIC_FMTSTR
                                                                                 },
                                                                                 &match (&"Texture",
                                                                                         &name)
                                                                                      {
                                                                                      (__arg0,
                                                                                       __arg1)
                                                                                      =>
                                                                                      [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                   ::std::fmt::Display::fmt),
                                                                                       ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                   ::std::fmt::Display::fmt)],
                                                                                  })))),
            }
        }
        pub fn get_or_load_texture(&mut self, name: &str,
                                   factory: &mut Factory)
         -> io::Result<&Texture> {
            match self.textures.get_mut(name) {
                Some(asset) => asset.get_or_load(factory),
                None =>
                Err(Error::new(ErrorKind::Other,
                               $crate::fmt::format(::std::fmt::Arguments::new_v1({
                                                                                     static __STATIC_FMTSTR:
                                                                                            &'static [&'static str]
                                                                                            =
                                                                                         &["",
                                                                                           " asset not found: "];
                                                                                     __STATIC_FMTSTR
                                                                                 },
                                                                                 &match (&"Texture",
                                                                                         &name)
                                                                                      {
                                                                                      (__arg0,
                                                                                       __arg1)
                                                                                      =>
                                                                                      [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                   ::std::fmt::Display::fmt),
                                                                                       ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                   ::std::fmt::Display::fmt)],
                                                                                  })))),
            }
        }
        pub fn add_texture_assets<S: Clone +
                                  Into<P>>(&mut self,
                                           names: &[(&'static str, S)]) {
            for &(ref name, ref path) in names {
                self.textures.insert(*name, Asset::new(path.clone().into()));
            }
        }
    }
}
mod platform {
    #[cfg(not(target_os = "windows"))]
    pub mod misc {
        pub const NEWLINE: &'static str = "\n";
    }
}
fn main() {
    hslog::init();
    log_panics::init();
    {
        static _LOC: $crate::LogLocation =
            $crate::LogLocation{__line: 56u32,
                                __file: "main.rs",
                                __module_path: "horde_survival",};
        let lvl = $crate::LogLevel::Info;
        if lvl <= $crate::__static_max_level() &&
               lvl <= $crate::max_log_level() {
            $crate::__log(lvl, "horde_survival", &_LOC,
                          ::std::fmt::Arguments::new_v1({
                                                            static __STATIC_FMTSTR:
                                                                   &'static [&'static str]
                                                                   =
                                                                &["Initializing game..."];
                                                            __STATIC_FMTSTR
                                                        },
                                                        &match () {
                                                             () => [],
                                                         }))
        }
    };
    let mut game = gamestate::GameState::new();
    let options =
        hsgraphics::GraphicsOptions::new().window_size(800,
                                                       600).minimap_enabled(false).display_debug(true).crosshair(true).fullscreen(false).clone();
    let (mut graphics, window) =
        hsgraphics::GraphicsState::new(options, &game);
    let mut loop_type = gameloop::LoopType::Loading;
    let mut ticks = tps::Ticks::new();
    let mut ui = gui::UI::new();
    {
        static _LOC: $crate::LogLocation =
            $crate::LogLocation{__line: 73u32,
                                __file: "main.rs",
                                __module_path: "horde_survival",};
        let lvl = $crate::LogLevel::Info;
        if lvl <= $crate::__static_max_level() &&
               lvl <= $crate::max_log_level() {
            $crate::__log(lvl, "horde_survival", &_LOC,
                          ::std::fmt::Arguments::new_v1({
                                                            static __STATIC_FMTSTR:
                                                                   &'static [&'static str]
                                                                   =
                                                                &["Done"];
                                                            __STATIC_FMTSTR
                                                        },
                                                        &match () {
                                                             () => [],
                                                         }))
        }
    };
    let mut events = window.poll_events();
    loop  {
        let event = events.next();
        match loop_type {
            gameloop::LoopType::Loading =>
            gameloop::loading_screen(&mut ui, &mut graphics, &window,
                                     &mut loop_type),
            gameloop::LoopType::Game =>
            gameloop::gametick(event, &mut ui, &mut game, &mut graphics,
                               &window, &mut ticks, &mut loop_type),
            gameloop::LoopType::GUI =>
            gameloop::run_gui(event, &mut ui, &mut game, &mut graphics,
                              &window, &mut ticks, &mut loop_type),
        }
        if graphics.should_close {
            {
                static _LOC: $crate::LogLocation =
                    $crate::LogLocation{__line: 88u32,
                                        __file: "main.rs",
                                        __module_path: "horde_survival",};
                let lvl = $crate::LogLevel::Info;
                if lvl <= $crate::__static_max_level() &&
                       lvl <= $crate::max_log_level() {
                    $crate::__log(lvl, "horde_survival", &_LOC,
                                  ::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["Closed Horde Survival"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match () {
                                                                     () => [],
                                                                 }))
                }
            };
            break ;
        }
    }
}
